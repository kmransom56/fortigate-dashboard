<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>FortiGate Network Topology 3D</title>
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
            rel="stylesheet"
        />
        <style>
            body {
                background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            }
            .top-bar {
                margin-bottom: 1rem;
            }
            .topology-container {
                background: white;
                border-radius: 20px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
                padding: 1rem;
                position: relative;
            }
            #graph-3d {
                width: 100%;
                height: 80vh;
                background: #ffffff;
                border-radius: 16px;
            }
            .loading-overlay {
                position: absolute;
                inset: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 16px;
            }
        </style>
    </head>
    <body>
        <div class="container-fluid p-4">
            <div
                class="d-flex justify-content-between align-items-center top-bar"
            >
                <div>
                    <h2 class="mb-1">
                        <i class="fas fa-cube me-2"></i>Network Topology 3D
                    </h2>
                    <p class="mb-0 text-muted">
                        Interactive 3D Security Fabric View
                    </p>
                </div>
                <div class="d-flex gap-2">
                    <a class="btn btn-outline-secondary btn-sm" href="/topology"
                        ><i class="fas fa-layer-group me-1"></i>2D Topology
                        View</a
                    >
                    <button
                        id="autoRotateBtn"
                        class="btn btn-outline-dark btn-sm"
                        title="Toggle auto-rotate"
                    >
                        <i class="fas fa-sync-alt me-1"></i>Auto-rotate
                    </button>
                    <button
                        id="fitBtn"
                        class="btn btn-outline-dark btn-sm"
                        title="Fit to graph"
                    >
                        <i class="fas fa-compress-arrows-alt me-1"></i>Fit
                    </button>
                    <div
                        class="form-check form-switch d-inline-flex align-items-center ms-2"
                        title="Performance mode"
                    >
                        <input
                            class="form-check-input"
                            type="checkbox"
                            id="perfModeSwitch"
                        />
                        <label
                            class="form-check-label ms-1"
                            for="perfModeSwitch"
                            >Performance</label
                        >
                    </div>
                    <div
                        class="form-check form-switch d-inline-flex align-items-center ms-2"
                        title="Shadows"
                    >
                        <input
                            class="form-check-input"
                            type="checkbox"
                            id="shadowsSwitch"
                            checked
                        />
                        <label class="form-check-label ms-1" for="shadowsSwitch"
                            >Shadows</label
                        >
                    </div>
                    <div
                        class="form-check form-switch d-inline-flex align-items-center ms-2"
                        title="Animations"
                    >
                        <input
                            class="form-check-input"
                            type="checkbox"
                            id="animationsSwitch"
                            checked
                        />
                        <label
                            class="form-check-label ms-1"
                            for="animationsSwitch"
                            >Animations</label
                        >
                    </div>
                    <button
                        id="eraserExportBtn"
                        class="btn btn-outline-primary btn-sm"
                        disabled
                        title="Enable ERASER_ENABLED to activate"
                    >
                        <i class="fas fa-upload me-1"></i>Export to Eraser
                    </button>
                    <button
                        id="generate3DBtn"
                        class="btn btn-outline-success btn-sm"
                        title="Generate 3D icons"
                    >
                        <i class="fas fa-magic me-1"></i>Generate 3D Icons
                    </button>
                    <button
                        id="iconStatsBtn"
                        class="btn btn-outline-info btn-sm"
                        title="Show 3D icon statistics"
                    >
                        <i class="fas fa-chart-bar me-1"></i>3D Stats
                    </button>
                </div>
            </div>
            <div
                id="notif"
                class="position-fixed top-0 end-0 p-3"
                style="z-index: 1080"
                aria-live="polite"
                role="status"
                aria-atomic="true"
            ></div>
            <div class="topology-container">
                <div id="graph-3d" style="position: relative"></div>
                <div id="loading" class="loading-overlay">
                    <div class="text-center">
                        <div
                            class="spinner-border text-primary"
                            role="status"
                            aria-live="polite"
                            aria-label="Loading topology"
                        ></div>
                        <div class="mt-2 text-muted small">
                            Loading topology…
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
            rel="stylesheet"
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        />
        <script type="module">
            import * as THREE from "https://unpkg.com/three@0.150.0/build/three.module.js";
            window.THREE = THREE;
        </script>
        <script src="/static/js/3d-device-models.js"></script>
        <script src="/static/vendor/3d-force-graph.min.js" defer></script>

        <script>
            // Global error handlers to avoid stuck loading overlay
            function hideLoadingOverlay() {
                const l = document.getElementById("loading");
                if (l) l.style.display = "none";
            }
            window.addEventListener("error", (e) => {
                hideLoadingOverlay();
                try {
                    showNotice(`Runtime error: ${e.message}`, "danger", 10000);
                } catch {}
            });
            window.addEventListener("unhandledrejection", (e) => {
                hideLoadingOverlay();
                const msg =
                    e && e.reason && e.reason.message
                        ? e.reason.message
                        : "Unhandled promise rejection";
                try {
                    showNotice(`Runtime error: ${msg}`, "danger", 10000);
                } catch {}
            });

            function showNotice(message, type = "danger", timeoutMs = 5000) {
                let container = document.getElementById("notif");
                if (!container) {
                    container = document.createElement("div");
                    container.id = "notif";
                    container.className = "position-fixed top-0 end-0 p-3";
                    container.setAttribute("aria-live", "polite");
                    container.setAttribute("role", "status");
                    container.setAttribute("aria-atomic", "true");
                    document.body.appendChild(container);
                }
                const el = document.createElement("div");
                el.className = `alert alert-${type} shadow`;
                el.role = "alert";
                el.innerText = message;
                container.appendChild(el);
                if (timeoutMs) setTimeout(() => el.remove(), timeoutMs);
            }

            function loadScript(src) {
                return new Promise((resolve, reject) => {
                    const s = document.createElement("script");
                    s.src = src;
                    s.async = true;
                    s.onload = () => resolve();
                    s.onerror = () =>
                        reject(new Error(`Failed to load ${src}`));
                    document.head.appendChild(s);
                });
            }

            async function ensureDeps() {
                // Three.js is now loaded as ES module above
                if (typeof ForceGraph3D === "undefined") {
                    try {
                        await loadScript(
                            "/static/vendor/3d-force-graph.min.js",
                        );
                    } catch (e) {
                        showNotice(
                            "Could not load 3D Force Graph (CDN and local fallback failed).",
                            "danger",
                            8000,
                        );
                        throw e;
                    }
                }
            }
        </script>

        <script>
            const TYPE_COLORS = {
                fortigate: "#2563eb",
                fortiswitch: "#059669",
                endpoint: "#7c3aed",
                server: "#dc2626",
            };
            const RISK_SIZE = { low: 6, medium: 8, high: 10, critical: 12 };

            async function load3DData() {
                let res;
                try {
                    // Use new 3D topology API endpoint with Eraser AI integration
                    const abs = new URL(
                        "/api/topology_3d_data",
                        window.location.origin,
                    ).toString();
                    const controller = new AbortController();
                    const t = setTimeout(() => controller.abort(), 15000); // Longer timeout for 3D generation
                    res = await fetch(abs, {
                        cache: "no-store",
                        signal: controller.signal,
                    });
                    clearTimeout(t);
                } catch (e) {
                    showNotice(
                        "Network error loading topology data. Using fallback.",
                        "warning",
                    );
                    return {
                        devices: [
                            {
                                id: "fortigate_main",
                                type: "fortigate",
                                name: "FortiGate-Main",
                                ip: "192.168.0.254",
                                risk: "low",
                                details: { status: "Active" },
                            },
                            {
                                id: "switch_0",
                                type: "fortiswitch",
                                name: "FortiSwitch-1",
                                ip: "192.168.0.10",
                                risk: "medium",
                                details: { status: "Authorized" },
                            },
                            {
                                id: "device_0",
                                type: "endpoint",
                                name: "Workstation",
                                ip: "192.168.0.101",
                                risk: "low",
                                details: { manufacturer: "Generic" },
                            },
                        ],
                        connections: [
                            { from: "fortigate_main", to: "switch_0" },
                            { from: "switch_0", to: "device_0" },
                        ],
                    };
                }
                if (!res.ok) {
                    showNotice(
                        `Failed to load topology data (${res.status})`,
                        "danger",
                    );
                    // Fallback to minimal sample data
                    return {
                        devices: [
                            {
                                id: "fortigate_main",
                                type: "fortigate",
                                name: "FortiGate-Main",
                                ip: "192.168.0.254",
                                risk: "low",
                                details: { status: "Active" },
                            },
                            {
                                id: "switch_0",
                                type: "fortiswitch",
                                name: "FortiSwitch-1",
                                ip: "192.168.0.10",
                                risk: "medium",
                                details: { status: "Authorized" },
                            },
                            {
                                id: "device_0",
                                type: "endpoint",
                                name: "Workstation",
                                ip: "192.168.0.101",
                                risk: "low",
                                details: { manufacturer: "Generic" },
                            },
                        ],
                        connections: [
                            { from: "fortigate_main", to: "switch_0" },
                            { from: "switch_0", to: "device_0" },
                        ],
                    };
                }
                try {
                    return await res.json();
                } catch (e) {
                    // If JSON parsing fails, use fallback
                    return {
                        devices: [
                            {
                                id: "fortigate_main",
                                type: "fortigate",
                                name: "FortiGate-Main",
                                ip: "192.168.0.254",
                                risk: "low",
                                details: { status: "Active" },
                            },
                        ],
                        connections: [],
                    };
                }
            }

            function to3DGraphData(topology) {
                const nodes = (topology.devices || []).map((d) => ({
                    id: d.id,
                    name: d.name,
                    type: d.type,
                    risk: d.risk || "low",
                    ip: d.ip || "N/A",
                    mac: d.mac || "",
                    details: d.details || {},
                    // 3D-specific properties
                    icon3D: d["3d_icon"] || null,
                    position3D: d["position_3d"] || null,
                    animation: d.animation || null,
                    // Enhanced metadata
                    manufacturer: d.manufacturer || "Unknown",
                    model: d.model || "",
                    status: d.status || "unknown",
                }));

                const links = (topology.connections || []).map((c) => ({
                    source: c.from,
                    target: c.to,
                    // 3D connection properties
                    properties3D: c["3d_properties"] || {
                        line_width: 0.1,
                        color: "#4A90E2",
                        opacity: 0.7,
                        animate_flow: false,
                    },
                }));

                return {
                    nodes,
                    links,
                    metadata: topology.metadata || {},
                };
            }

            let performanceMode = false;

            function makeLabelSprite(text, fontSizePx) {
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");
                const pad = 36;
                ctx.font = `bold ${fontSizePx}px Segoe UI, Arial, sans-serif`;
                const textWidth = ctx.measureText(text).width;
                canvas.width = textWidth + pad;
                canvas.height = fontSizePx + pad;
                ctx.font = `bold ${fontSizePx}px Segoe UI, Arial, sans-serif`;
                // semi-transparent rounded rect background for contrast
                const radius = 10;
                ctx.fillStyle = "rgba(17,24,39,0.8)";
                ctx.beginPath();
                ctx.moveTo(radius, 0);
                ctx.arcTo(canvas.width, 0, canvas.width, canvas.height, radius);
                ctx.arcTo(
                    canvas.width,
                    canvas.height,
                    0,
                    canvas.height,
                    radius,
                );
                ctx.arcTo(0, canvas.height, 0, 0, radius);
                ctx.arcTo(0, 0, canvas.width, 0, radius);
                ctx.closePath();
                ctx.fill();
                // text
                ctx.fillStyle = "#F9FAFB";
                ctx.textBaseline = "middle";
                ctx.fillText(text, pad / 2, canvas.height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                texture.generateMipmaps = false;
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                });
                material.depthWrite = false;
                const sprite = new THREE.Sprite(material);
                const scaleDivisor = performanceMode ? 5.5 : 4.5;
                sprite.scale.set(
                    canvas.width / scaleDivisor,
                    canvas.height / scaleDivisor,
                    1,
                );
                sprite.position.set(0, -12, 0);
                return sprite;
            }

            function makeNodeObject(node) {
                const group = new THREE.Group();
                const size = RISK_SIZE[node.risk] || 10;

                // Use realistic 3D models from 3d-device-models.js
                if (typeof window.create3DDeviceModel === "function") {
                    try {
                        const deviceModel = window.create3DDeviceModel(
                            node.type || "endpoint",
                            size,
                        );
                        deviceModel.castShadow = true;
                        deviceModel.receiveShadow = true;
                        group.add(deviceModel);
                    } catch (e) {
                        console.warn(
                            "Failed to create 3D device model, using fallback:",
                            e,
                        );
                        createFallbackGeometry(
                            group,
                            node,
                            size,
                            new THREE.Color(
                                TYPE_COLORS[node.type] || "#6b7280",
                            ),
                        );
                    }
                } else {
                    // Fallback if 3D models not loaded
                    console.warn(
                        "3D device models not available, using fallback geometry",
                    );
                    createFallbackGeometry(
                        group,
                        node,
                        size,
                        new THREE.Color(TYPE_COLORS[node.type] || "#6b7280"),
                    );
                }

                // Add shadow platform beneath device
                const platformGeom = new THREE.CylinderGeometry(
                    size * 0.8,
                    size * 0.8,
                    size * 0.05,
                    24,
                );
                const platformMat = new THREE.MeshPhongMaterial({
                    color: 0x1a1a1a,
                    shininess: 10,
                    transparent: true,
                    opacity: 0.3,
                });
                const platform = new THREE.Mesh(platformGeom, platformMat);
                platform.position.y = -size * 0.3;
                platform.receiveShadow = true;
                group.add(platform);

                // Add glow effect for high-risk devices
                if (!performanceMode && node.risk && node.risk !== "low") {
                    const glowGeom = new THREE.SphereGeometry(
                        size * 1.2,
                        16,
                        16,
                    );
                    const riskColor =
                        node.risk === "critical"
                            ? 0xdc2626
                            : node.risk === "high"
                              ? 0xef4444
                              : 0xf59e0b;
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: riskColor,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.BackSide,
                    });
                    const glow = new THREE.Mesh(glowGeom, glowMat);
                    group.add(glow);
                }

                // Enhanced label with better positioning
                const labelFont = performanceMode ? 36 : 48;
                const label = makeLabelSprite(node.name || node.id, labelFont);
                label.position.set(0, -size * 1.8, 0);
                group.add(label);

                // Add subtle rotation animation for active devices
                if (
                    !performanceMode &&
                    node.details &&
                    node.details.status === "Active"
                ) {
                    group.userData.rotationSpeed = 0.005;
                }

                return group;
            }

            function create3DDeviceObject(node, size) {
                const group = new THREE.Group();
                const color = TYPE_COLORS[node.type] || TYPE_COLORS.endpoint;

                // Check if we have 3D icon data from Eraser AI
                if (node.icon3D && node.icon3D.threejs) {
                    return createEraserAI3DObject(group, node, size, color);
                }

                // Fallback to traditional icon-based 3D rendering
                return createTraditional3DObject(group, node, size, color);
            }

            function createEraserAI3DObject(group, node, size, color) {
                const icon3D = node.icon3D;
                const threejsData = icon3D.threejs;

                try {
                    // Create geometry based on Eraser AI specifications
                    let geometry;
                    const geomData = threejsData.geometry;

                    switch (geomData.type) {
                        case "BoxGeometry":
                            geometry = new THREE.BoxGeometry(...geomData.args);
                            break;
                        case "CylinderGeometry":
                            geometry = new THREE.CylinderGeometry(
                                ...geomData.args,
                            );
                            break;
                        case "SphereGeometry":
                            geometry = new THREE.SphereGeometry(
                                ...geomData.args,
                            );
                            break;
                        default:
                            geometry = new THREE.BoxGeometry(
                                size,
                                size * 0.6,
                                size * 0.8,
                            );
                    }

                    // Create material with Eraser AI texture
                    let material;
                    const matData = threejsData.material;

                    if (matData.map && matData.map !== "undefined") {
                        // Load texture from Eraser AI or fallback
                        const textureLoader = new THREE.TextureLoader();
                        const texture = textureLoader.load(
                            matData.map,
                            // Success callback
                            function (texture) {
                                console.log(
                                    "Loaded 3D texture from Eraser AI:",
                                    matData.map,
                                );
                            },
                            // Progress callback
                            undefined,
                            // Error callback
                            function (error) {
                                console.warn(
                                    "Failed to load 3D texture, using color fallback:",
                                    error,
                                );
                                material.map = null;
                                material.color.setHex(color.replace("#", "0x"));
                            },
                        );

                        material = new THREE.MeshPhongMaterial({
                            map: texture,
                            color: threejsData.color || color,
                            transparent: matData.transparent || true,
                            opacity: matData.opacity || 0.9,
                            shininess: matData.shininess || 30,
                        });
                    } else {
                        // No texture, use enhanced color material
                        material = new THREE.MeshPhongMaterial({
                            color: threejsData.color || color,
                            transparent: true,
                            opacity: 0.9,
                            shininess: 60,
                            specular: 0x222222,
                        });
                    }

                    // Create main mesh
                    const mesh = new THREE.Mesh(geometry, material);

                    // Apply position from geometry data
                    if (geomData.position) {
                        mesh.position.set(...geomData.position);
                    }

                    // Apply scale from 3D data
                    const scale = threejsData.scale || [1, 1, 1];
                    mesh.scale.set(...scale.map((s) => s * size));

                    group.add(mesh);

                    // Add enhanced lighting effects for Eraser AI objects
                    if (!performanceMode) {
                        addEnhanced3DEffects(
                            group,
                            node,
                            size,
                            threejsData.color || color,
                        );
                    }

                    // Add metadata for animations
                    group.userData = {
                        deviceType: node.type,
                        eraserGenerated: true,
                        animationData: node.animation || null,
                        originalIcon: icon3D.original_svg || null,
                    };

                    console.log(
                        `Created Eraser AI 3D object for ${node.name}:`,
                        {
                            type: icon3D.type,
                            geometry: geomData.type,
                            hasTexture: !!matData.map,
                            scale: scale,
                        },
                    );
                } catch (error) {
                    console.warn(
                        "Failed to create Eraser AI 3D object, using fallback:",
                        error,
                    );
                    return createFallbackGeometry(group, node, size, color);
                }

                return group;
            }

            function createTraditional3DObject(group, node, size, color) {
                // Traditional icon-based 3D rendering (existing implementation)
                const iconPath = node.details?.iconPath;

                if (iconPath) {
                    try {
                        const iconSize = size * 1.2;
                        const loader = new THREE.TextureLoader();
                        const iconTexture = loader.load(`/${iconPath}`);

                        const iconGeom = new THREE.PlaneGeometry(
                            iconSize,
                            iconSize,
                        );
                        const iconMat = new THREE.MeshBasicMaterial({
                            map: iconTexture,
                            transparent: true,
                            alphaTest: 0.1,
                            side: THREE.DoubleSide,
                        });

                        const iconMesh = new THREE.Mesh(iconGeom, iconMat);
                        iconMesh.position.y = size * 0.1;
                        iconMesh.userData.isIcon = true;
                        group.add(iconMesh);

                        // Add glow effect
                        if (!performanceMode) {
                            const glowGeom = new THREE.PlaneGeometry(
                                iconSize * 1.2,
                                iconSize * 1.2,
                            );
                            const glowMat = new THREE.MeshBasicMaterial({
                                color: color,
                                transparent: true,
                                opacity: 0.2,
                                side: THREE.DoubleSide,
                            });
                            const glow = new THREE.Mesh(glowGeom, glowMat);
                            glow.position.y = size * 0.09;
                            glow.userData.isIcon = true;
                            group.add(glow);
                        }
                    } catch (e) {
                        console.warn(
                            "Failed to load traditional icon, using geometry fallback:",
                            e,
                        );
                        createFallbackGeometry(group, node, size, color);
                    }
                } else {
                    createFallbackGeometry(group, node, size, color);
                }

                return group;
            }

            function addEnhanced3DEffects(group, node, size, color) {
                // Enhanced effects for 3D objects

                // Status-based effects
                if (
                    node.status === "online" ||
                    node.details?.status === "Active"
                ) {
                    // Add subtle pulsing glow for active devices
                    const glowGeometry = new THREE.SphereGeometry(
                        size * 1.1,
                        16,
                        16,
                    );
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.BackSide,
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    glowMesh.userData.pulseEffect = true;
                    group.add(glowMesh);
                }

                // Risk-based effects
                if (node.risk && node.risk !== "low") {
                    const riskColors = {
                        medium: 0xfbbf24,
                        high: 0xf59e0b,
                        critical: 0xdc2626,
                    };

                    const riskGeometry = new THREE.RingGeometry(
                        size * 0.8,
                        size * 1.0,
                        16,
                    );
                    const riskMaterial = new THREE.MeshBasicMaterial({
                        color: riskColors[node.risk] || 0xf59e0b,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide,
                    });
                    const riskRing = new THREE.Mesh(riskGeometry, riskMaterial);
                    riskRing.rotation.x = -Math.PI / 2;
                    riskRing.position.y = -size * 0.1;
                    riskRing.userData.rotateEffect = true;
                    group.add(riskRing);
                }
            }

            function createFallbackGeometry(group, node, size, color) {
                // Fallback to geometric shapes when no icon is available
                const deviceType = node.type || "endpoint";
                const segments = performanceMode ? 10 : 16;

                let geom, mat;

                switch (deviceType) {
                    case "fortigate":
                        geom = new THREE.BoxGeometry(
                            size * 0.6,
                            size * 0.4,
                            size * 0.3,
                        );
                        mat = new THREE.MeshPhongMaterial({
                            color,
                            shininess: 120,
                            transparent: true,
                            opacity: 0.95,
                            specular: 0x222222,
                        });
                        break;
                    case "fortiswitch":
                        geom = new THREE.CylinderGeometry(
                            size * 0.3,
                            size * 0.3,
                            size * 0.2,
                            8,
                        );
                        mat = new THREE.MeshPhongMaterial({
                            color,
                            shininess: 60,
                            specular: 0x111111,
                        });
                        break;
                    case "server":
                        geom = new THREE.BoxGeometry(
                            size * 0.5,
                            size * 0.3,
                            size * 0.3,
                        );
                        mat = new THREE.MeshPhongMaterial({
                            color,
                            shininess: 100,
                            transparent: true,
                            opacity: 0.95,
                            specular: 0x333333,
                        });
                        break;
                    default:
                        geom = new THREE.SphereGeometry(
                            size * 0.3,
                            segments,
                            segments,
                        );
                        mat = new THREE.MeshPhongMaterial({
                            color,
                            shininess: 30,
                            specular: 0x111111,
                        });
                }

                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.y = size * 0.1;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            }

            function nodeLabel(node) {
                const status =
                    node.details && node.details.status
                        ? node.details.status
                        : "online";
                const man =
                    node.details && node.details.manufacturer
                        ? node.details.manufacturer
                        : "";
                const host =
                    node.details && node.details.hostname
                        ? node.details.hostname
                        : "";
                return `
        <div style="font-size:12px">
          <div><strong>${node.name}</strong></div>
          <div>IP: ${node.ip}</div>
          <div>Status: ${status}</div>
          <div>Risk: ${node.risk}</div>
          ${node.mac ? `<div>MAC: ${node.mac}</div>` : ""}
          ${man ? `<div>Manufacturer: ${man}</div>` : ""}
          ${host ? `<div>Hostname: ${host}</div>` : ""}
        </div>
      `;
            }

            window.addEventListener("DOMContentLoaded", async () => {
                const hideLoading = hideLoadingOverlay;
                // Safety timer to ensure overlay never hangs forever
                setTimeout(() => {
                    const stillVisible =
                        document.getElementById("loading") &&
                        document.getElementById("loading").style.display !==
                            "none";
                    if (stillVisible) {
                        hideLoading();
                        showNotice(
                            "Took too long to load. Showing what we have.",
                            "warning",
                            6000,
                        );
                    }
                }, 12000);
                try {
                    await ensureDeps();
                } catch (e) {
                    hideLoading();
                    showNotice(
                        "3D libraries failed to load. Check network or local vendor files.",
                        "danger",
                        8000,
                    );
                    console.error(e);
                    return;
                }
                let raw;
                try {
                    showNotice(
                        "Loading 3D topology with Eraser AI integration...",
                        "info",
                        3000,
                    );
                    raw = await load3DData();
                } catch (e) {
                    console.warn(
                        "Falling back to sample topology after load error:",
                        e,
                    );
                    showNotice(
                        "Using sample topology (3D API error).",
                        "warning",
                        5000,
                    );
                    raw = {
                        devices: [
                            {
                                id: "fortigate_main",
                                type: "fortigate",
                                name: "FortiGate-Main",
                                ip: "192.168.0.254",
                                risk: "low",
                                details: { status: "Degraded" },
                            },
                        ],
                        connections: [],
                    };
                }
                const data = to3DGraphData(raw);

                // Log 3D features status
                if (raw.metadata) {
                    console.log("3D Topology Features:", {
                        "3D Enabled": raw.metadata["3d_enabled"],
                        "Eraser AI Enabled": raw.metadata.eraser_ai_enabled,
                        "3D Icons Stats": raw.metadata["3d_icon_stats"],
                        "Devices with 3D Icons": data.nodes.filter(
                            (n) => n.icon3D,
                        ).length,
                    });

                    if (raw.metadata.eraser_ai_enabled) {
                        showNotice(
                            "✨ Eraser AI 3D icons enabled!",
                            "success",
                            4000,
                        );
                    }
                }

                const containerEl = document.getElementById("graph-3d");
                const Graph = ForceGraph3D()(containerEl)
                    .graphData(data)
                    .nodeThreeObject((node) => {
                        const size = RISK_SIZE[node.risk] || 6;
                        const nodeObject = create3DDeviceObject(node, size);

                        // Add enhanced label with better positioning
                        const labelFont = performanceMode ? 36 : 48;
                        const label = makeLabelSprite(
                            node.name || node.id,
                            labelFont,
                        );
                        label.position.set(0, -size * 1.5, 0);
                        nodeObject.add(label);

                        // Store reference to node data for interactions
                        nodeObject.userData.nodeData = node;

                        return nodeObject;
                    })
                    .nodeLabel(nodeLabel)
                    .nodeColor((n) => TYPE_COLORS[n.type] || "#6b7280")
                    .nodeRelSize(4)
                    .linkOpacity(0.6)
                    .linkWidth(2)
                    .linkColor(() => "#4a90e2")
                    .linkDirectionalArrowLength(3)
                    .linkDirectionalArrowColor(() => "#2c5aa0")
                    .linkDirectionalArrowRelPos(0.5)
                    .linkThreeObjectExtend(true)
                    .linkThreeObject((link) => {
                        const group = new THREE.Group();

                        // Get 3D properties from link data
                        const props3D = link.properties3D || {
                            line_width: 0.1,
                            color: "#4A90E2",
                            opacity: 0.7,
                            animate_flow: false,
                            flow_speed: 2.0,
                        };

                        // Create enhanced animated particles along the link
                        if (!performanceMode && props3D.animate_flow) {
                            const particleCount = 5;
                            const particles = [];

                            for (let i = 0; i < particleCount; i++) {
                                const particleGeom = new THREE.SphereGeometry(
                                    props3D.line_width * 5,
                                    8,
                                    8,
                                );
                                const particleMat = new THREE.MeshBasicMaterial(
                                    {
                                        color: new THREE.Color(props3D.color),
                                        transparent: true,
                                        opacity: props3D.opacity * 0.8,
                                    },
                                );
                                const particle = new THREE.Mesh(
                                    particleGeom,
                                    particleMat,
                                );

                                particle.position.x =
                                    (i / particleCount) * 2 - 1; // Start at different positions
                                particle.userData.speed =
                                    0.5 + Math.random() * 0.5; // Random speed
                                particles.push(particle);
                                group.add(particle);
                            }

                            group.userData.particles = particles;
                        }

                        return group;
                    })
                    .backgroundColor("#f8fafc")
                    .showNavInfo(false);

                // Ensure correct initial sizing and handle window resize
                function resizeGraph() {
                    const width =
                        containerEl.clientWidth ||
                        containerEl.offsetWidth ||
                        800;
                    const height =
                        containerEl.clientHeight ||
                        containerEl.offsetHeight ||
                        Math.round(window.innerHeight * 0.8);
                    Graph.width(width);
                    Graph.height(height);
                }
                resizeGraph();
                window.addEventListener("resize", resizeGraph);

                const scene = Graph.scene();

                // Enhanced lighting system
                const ambient = new THREE.AmbientLight(0x404040, 0.4); // Reduced ambient for more dramatic lighting
                scene.add(ambient);

                // Main directional light with shadows
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
                dirLight.position.set(50, 50, 50);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 500;
                dirLight.shadow.camera.left = -100;
                dirLight.shadow.camera.right = 100;
                dirLight.shadow.camera.top = 100;
                dirLight.shadow.camera.bottom = -100;
                scene.add(dirLight);

                // Secondary fill light
                const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.3);
                fillLight.position.set(-30, 30, -30);
                scene.add(fillLight);

                // Rim light for edge definition
                const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
                rimLight.position.set(0, 0, -50);
                scene.add(rimLight);

                // Add ground plane for shadows
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0xf0f0f0,
                    transparent: true,
                    opacity: 0.3,
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -50;
                ground.receiveShadow = true;
                scene.add(ground);

                const controls = Graph.controls();
                controls.enableZoom = true;
                controls.autoRotate = false;
                controls.autoRotateSpeed = 1.0;

                // Enhanced renderer settings
                const renderer = Graph.renderer();
                if (renderer) {
                    renderer.setPixelRatio(
                        Math.min(2, window.devicePixelRatio),
                    );
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    renderer.antialias = true;
                    renderer.setClearColor(0xf8fafc, 1.0); // Light gray background
                }

                Graph.onNodeClick(async (n) => {
                    try {
                        const statusRes = await fetch(
                            new URL(
                                "/api/eraser/status",
                                window.location.origin,
                            ),
                        );
                        const status = statusRes.ok
                            ? await statusRes.json()
                            : { enabled: false };

                        if (
                            status &&
                            status.enabled &&
                            n &&
                            n.details &&
                            n.details.iconPath
                        ) {
                            showNotice("Generating 3D asset...", "info", 2000);

                            const abs = n.details.iconPath.startsWith("/")
                                ? n.details.iconPath
                                : `/static/${n.details.iconPath}`;
                            const res = await fetch(
                                new URL(
                                    "/api/eraser/export",
                                    window.location.origin,
                                ),
                                {
                                    method: "POST",
                                    headers: {
                                        "Content-Type": "application/json",
                                    },
                                    body: JSON.stringify({ imageUrl: abs }),
                                },
                            );

                            if (res.ok) {
                                const js = await res.json();

                                // Enhanced 3D asset handling
                                if (js && (js.textureUrl || js.modelUrl)) {
                                    if (js.textureUrl) {
                                        // Apply new 3D texture
                                        n.details.textureUrl = js.textureUrl;
                                        n.details.eraserGenerated = true;

                                        // Rebuild the node object to apply the new texture
                                        Graph.nodeThreeObject(makeNodeObject);
                                        Graph.graphData(Graph.graphData());

                                        showNotice(
                                            "✨ Applied 3D texture from Eraser AI",
                                            "success",
                                            3000,
                                        );
                                    } else if (js.modelUrl) {
                                        showNotice(
                                            "🎯 3D model generated (advanced integration needed)",
                                            "info",
                                            4000,
                                        );
                                    }
                                } else if (js.status === "fallback") {
                                    showNotice(
                                        "Using enhanced fallback 3D representation",
                                        "warning",
                                        2500,
                                    );
                                } else {
                                    showNotice(
                                        "Eraser processing completed",
                                        "success",
                                        2500,
                                    );
                                }
                            } else {
                                showNotice(
                                    "Eraser API error - using fallback",
                                    "warning",
                                    2500,
                                );
                            }
                        } else if (n && n.details) {
                            // Show device info
                            const deviceInfo = `
              <strong>${n.name}</strong><br>
              Type: ${n.type}<br>
              Manufacturer: ${n.details.manufacturer || "Unknown"}<br>
              Status: ${n.details.status || "Unknown"}<br>
              ${n.details.iconPath ? `Icon: ${n.details.iconTitle || "Available"}` : "No icon available"}
            `;
                            showNotice(deviceInfo, "info", 3000);
                        }
                    } catch (e) {
                        showNotice("Error processing 3D asset", "danger", 2500);
                        console.error("Eraser integration error:", e);
                    }
                    console.log("Selected:", n);
                });

                // Initial simulation tuning for faster first paint
                try {
                    if (typeof Graph.cooldownTicks === "function")
                        Graph.cooldownTicks(140);
                    if (typeof Graph.enableNodeDrag === "function")
                        Graph.enableNodeDrag(true);
                    const charge = Graph.d3Force && Graph.d3Force("charge");
                    if (charge && typeof charge.strength === "function")
                        charge.strength(-70);
                    // Link distance tuned for hierarchical layers
                    if (typeof Graph.d3Force === "function") {
                        const link = Graph.d3Force("link");
                        if (link && typeof link.distance === "function")
                            link.distance((l) =>
                                l.source?.type === "fortigate" ? 180 : 110,
                            );
                    }
                } catch {}

                const eraserStatusUrl = new URL(
                    "/api/eraser/status",
                    window.location.origin,
                ).toString();
                fetch(eraserStatusUrl)
                    .then((r) => (r.ok ? r.json() : { enabled: false }))
                    .then((js) => {
                        if (js && js.enabled) {
                            document.getElementById(
                                "eraserExportBtn",
                            ).disabled = false;
                        }
                    })
                    .catch(() => {});

                document
                    .getElementById("eraserExportBtn")
                    .addEventListener("click", async () => {
                        try {
                            const exportUrl = new URL(
                                "/api/eraser/export",
                                window.location.origin,
                            ).toString();
                            const res = await fetch(exportUrl, {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ topology: raw }),
                            });
                            if (!res.ok) {
                                showNotice(
                                    `Export failed (${res.status})`,
                                    "danger",
                                );
                                return;
                            }
                            const js = await res.json();
                            showNotice(
                                js.message || "Exported",
                                "success",
                                3000,
                            );
                        } catch (e) {
                            showNotice(
                                "Eraser export not available",
                                "warning",
                            );
                        }
                    });

                // Hide loading overlay once initial frame is likely rendered
                setTimeout(hideLoading, 300);

                // Animation loop will be defined later with controls

                // Auto-rotate toggle
                const autoRotateBtn = document.getElementById("autoRotateBtn");
                let autoRotating = false;
                function setAutoRotate(on) {
                    autoRotating = on;
                    controls.autoRotate = on;
                    if (controls.update) controls.update();
                    autoRotateBtn.classList.toggle("btn-primary", on);
                    autoRotateBtn.classList.toggle("btn-outline-dark", !on);
                }
                autoRotateBtn.addEventListener("click", () =>
                    setAutoRotate(!autoRotating),
                );

                // Fit-to-graph
                const fitBtn = document.getElementById("fitBtn");
                function fitToGraph() {
                    // Prefer built-in zoomToFit if available
                    try {
                        if (typeof Graph.zoomToFit === "function") {
                            Graph.zoomToFit(1000, 100);
                            return;
                        }
                    } catch (e) {}
                    const nodes =
                        (Graph.graphData() && Graph.graphData().nodes) || [];
                    if (!nodes.length) return;
                    const withPos = nodes.filter(
                        (n) =>
                            Number.isFinite(n.x) &&
                            Number.isFinite(n.y) &&
                            Number.isFinite(n.z),
                    );
                    const pts = withPos.length
                        ? withPos
                        : nodes.map((n) => ({ x: 0, y: 0, z: 0 }));
                    let minX = Infinity,
                        minY = Infinity,
                        minZ = Infinity,
                        maxX = -Infinity,
                        maxY = -Infinity,
                        maxZ = -Infinity;
                    let cx = 0,
                        cy = 0,
                        cz = 0;
                    pts.forEach((p) => {
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y);
                        maxY = Math.max(maxY, p.y);
                        minZ = Math.min(minZ, p.z);
                        maxZ = Math.max(maxZ, p.z);
                        cx += p.x;
                        cy += p.y;
                        cz += p.z;
                    });
                    cx /= pts.length;
                    cy /= pts.length;
                    cz /= pts.length;
                    const dx = maxX - minX,
                        dy = maxY - minY,
                        dz = maxZ - minZ;
                    const radius = Math.max(dx, dy, dz) / 2 || 100;
                    const camera = Graph.camera();
                    const fov = camera && camera.fov ? camera.fov : 60;
                    const fovRad = (fov * Math.PI) / 180;
                    const distance = (radius / Math.tan(fovRad / 2)) * 1.2;
                    Graph.cameraPosition(
                        { x: cx, y: cy, z: cz + distance },
                        { x: cx, y: cy, z: cz },
                        1000,
                    );
                }
                fitBtn.addEventListener("click", fitToGraph);

                // Fit once after simulation settles
                let fittedOnce = false;
                if (typeof Graph.onEngineStop === "function") {
                    Graph.onEngineStop(() => {
                        if (!fittedOnce) {
                            fitToGraph();
                            fittedOnce = true;
                        }
                    });
                }

                // Performance mode toggle
                const perfSwitch = document.getElementById("perfModeSwitch");
                function applyPerformanceMode(on) {
                    performanceMode = on;

                    // Renderer optimizations
                    if (renderer) {
                        renderer.setPixelRatio(
                            on ? 1 : Math.min(2, window.devicePixelRatio),
                        );
                        renderer.shadowMap.enabled = on ? false : true;
                        renderer.antialias = !on;
                    }

                    // Simulation tuning for performance
                    const charge = Graph.d3Force && Graph.d3Force("charge");
                    if (charge && typeof charge.strength === "function") {
                        charge.strength(on ? -40 : -120);
                    }
                    if (typeof Graph.cooldownTicks === "function") {
                        Graph.cooldownTicks(on ? 60 : 200);
                    }
                    if (typeof Graph.enableNodeDrag === "function") {
                        Graph.enableNodeDrag(!on);
                    }

                    // Visual quality adjustments
                    Graph.linkOpacity(on ? 0.4 : 0.6);
                    Graph.linkWidth(on ? 1 : 2);

                    // Disable animations in performance mode
                    if (on) {
                        animationsEnabled = false;
                        document.getElementById("animationsSwitch").checked =
                            false;
                    }

                    // Rebuild node objects to apply performance changes
                    Graph.nodeThreeObject(makeNodeObject);
                    Graph.graphData(Graph.graphData());

                    // Update shadow settings
                    toggleShadows(!on);
                }
                perfSwitch.addEventListener("change", (e) =>
                    applyPerformanceMode(e.target.checked),
                );

                // Shadows toggle
                const shadowsSwitch = document.getElementById("shadowsSwitch");
                function toggleShadows(enabled) {
                    if (renderer) {
                        renderer.shadowMap.enabled = enabled;
                    }
                    // Update all meshes
                    Graph.graphData().nodes.forEach((node) => {
                        if (node.__threeObj) {
                            node.__threeObj.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = enabled;
                                    child.receiveShadow = enabled;
                                }
                            });
                        }
                    });
                }
                shadowsSwitch.addEventListener("change", (e) =>
                    toggleShadows(e.target.checked),
                );

                // Animations toggle
                const animationsSwitch =
                    document.getElementById("animationsSwitch");
                let animationsEnabled = true;
                function toggleAnimations(enabled) {
                    animationsEnabled = enabled;
                    // Update rotation speeds
                    Graph.graphData().nodes.forEach((node) => {
                        if (node.__threeObj && node.__threeObj.userData) {
                            node.__threeObj.userData.rotationSpeed = enabled
                                ? node.__threeObj.userData
                                      .originalRotationSpeed || 0.01
                                : 0;
                        }
                    });
                }
                animationsSwitch.addEventListener("change", (e) =>
                    toggleAnimations(e.target.checked),
                );

                // Update animation loop to respect animations toggle
                function animate() {
                    requestAnimationFrame(animate);

                    if (!animationsEnabled) return;

                    // Rotate active devices
                    if (!performanceMode) {
                        Graph.graphData().nodes.forEach((node) => {
                            if (
                                node.__threeObj &&
                                node.__threeObj.userData.rotationSpeed
                            ) {
                                node.__threeObj.rotation.y +=
                                    node.__threeObj.userData.rotationSpeed;
                            }
                        });
                    }

                    // Update icon billboards to face camera
                    if (!performanceMode) {
                        const camera = Graph.camera();
                        Graph.graphData().nodes.forEach((node) => {
                            if (node.__threeObj && node.__threeObj.children) {
                                node.__threeObj.children.forEach((child) => {
                                    if (
                                        child.userData &&
                                        child.userData.isIcon
                                    ) {
                                        // Make icons always face the camera
                                        child.lookAt(camera.position);
                                    }
                                });
                            }
                        });
                    }

                    // Animate connection particles
                    if (!performanceMode && Graph.graphData().links) {
                        Graph.graphData().links.forEach((link) => {
                            if (
                                link.__threeObj &&
                                link.__threeObj.userData &&
                                link.__threeObj.userData.particles
                            ) {
                                link.__threeObj.userData.particles.forEach(
                                    (particle) => {
                                        particle.position.x +=
                                            particle.userData.speed * 0.1;
                                        if (particle.position.x > 1) {
                                            particle.position.x = -1;
                                        }
                                    },
                                );
                            }
                        });
                    }
                }
                animate();

                // Enhanced 3D icon generation handlers
                document
                    .getElementById("generate3DBtn")
                    .addEventListener("click", async () => {
                        try {
                            showNotice(
                                "🔮 Starting batch 3D icon generation...",
                                "info",
                            );

                            // Get current graph data to find devices with icons
                            const currentData = Graph.graphData();
                            const devices = currentData.nodes || [];

                            // Prepare SVG paths for batch generation
                            const svgPaths = devices
                                .filter(
                                    (device) =>
                                        device.details &&
                                        device.details.iconPath,
                                )
                                .map((device) => ({
                                    svg_path: `app/static/${device.details.iconPath}`,
                                    device_type: device.type || "endpoint",
                                    device_name:
                                        device.name || "Unknown Device",
                                }));

                            if (svgPaths.length === 0) {
                                showNotice(
                                    "⚠️ No devices with SVG icons found to convert",
                                    "warning",
                                );
                                return;
                            }

                            // Call batch generation API
                            const response = await fetch(
                                "/api/3d_icons/batch_generate",
                                {
                                    method: "POST",
                                    headers: {
                                        "Content-Type": "application/json",
                                    },
                                    body: JSON.stringify({
                                        svg_paths: svgPaths,
                                    }),
                                },
                            );

                            if (!response.ok) {
                                throw new Error(
                                    `HTTP ${response.status}: ${response.statusText}`,
                                );
                            }

                            const result = await response.json();
                            const stats = result.stats || {};

                            showNotice(
                                `✨ Generated ${stats.successful || 0} 3D icons in ${stats.duration_seconds || 0}s!`,
                                "success",
                                5000,
                            );

                            // Reload the 3D topology to show new icons
                            setTimeout(() => {
                                window.location.reload();
                            }, 2000);
                        } catch (error) {
                            console.error("3D icon generation failed:", error);
                            showNotice(
                                `❌ 3D icon generation failed: ${error.message}`,
                                "danger",
                                8000,
                            );
                        }
                    });

                // 3D icon statistics handler
                document
                    .getElementById("iconStatsBtn")
                    .addEventListener("click", async () => {
                        try {
                            const response = await fetch("/api/3d_icons/stats");

                            if (!response.ok) {
                                throw new Error(
                                    `HTTP ${response.status}: ${response.statusText}`,
                                );
                            }

                            const stats = await response.json();

                            // Create detailed stats display
                            const statsHtml = `
            <div class="card">
              <div class="card-header">
                <h5><i class="fas fa-cube me-2"></i>3D Icon Statistics</h5>
              </div>
              <div class="card-body">
                <div class="row">
                  <div class="col-md-6">
                    <h6>Cache Status</h6>
                    <ul class="list-unstyled">
                      <li><strong>Cached Icons:</strong> ${stats.cached_icons_count || 0}</li>
                      <li><strong>Cache Size:</strong> ${stats.cache_size_mb || 0} MB</li>
                      <li><strong>Cache Hits:</strong> ${stats.cache_hits || 0}</li>
                      <li><strong>Cache Misses:</strong> ${stats.cache_misses || 0}</li>
                    </ul>
                  </div>
                  <div class="col-md-6">
                    <h6>Generation Stats</h6>
                    <ul class="list-unstyled">
                      <li><strong>Total Generated:</strong> ${stats.total_generated || 0}</li>
                      <li><strong>Eraser Requests:</strong> ${stats.eraser_requests || 0}</li>
                      <li><strong>Fallback Used:</strong> ${stats.fallback_used || 0}</li>
                      <li><strong>Eraser Enabled:</strong> ${stats.eraser_enabled ? "✅" : "❌"}</li>
                    </ul>
                  </div>
                </div>
                <div class="mt-3">
                  <small class="text-muted">Last Updated: ${stats.last_updated || "Never"}</small>
                </div>
              </div>
            </div>
          `;

                            // Show stats in notification area
                            const notificationArea =
                                document.getElementById("notif");
                            const statsElement = document.createElement("div");
                            statsElement.className = "toast show";
                            statsElement.innerHTML = `
            <div class="toast-header">
              <strong class="me-auto">3D Icon Statistics</strong>
              <button type="button" class="btn-close" onclick="this.closest('.toast').remove()"></button>
            </div>
            <div class="toast-body">
              ${statsHtml}
            </div>
          `;

                            notificationArea.appendChild(statsElement);

                            // Auto-remove after 15 seconds
                            setTimeout(() => {
                                if (statsElement.parentNode) {
                                    statsElement.remove();
                                }
                            }, 15000);
                        } catch (error) {
                            console.error(
                                "Failed to get 3D icon stats:",
                                error,
                            );
                            showNotice(
                                `❌ Failed to get 3D icon statistics: ${error.message}`,
                                "danger",
                            );
                        }
                    });
            });
        </script>
    </body>
</html>
