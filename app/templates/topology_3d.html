<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FortiGate Network Topology 3D</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); }
    .top-bar { margin-bottom: 1rem; }
    .topology-container { background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); padding: 1rem; position: relative; }
    #graph-3d { width: 100%; height: 80vh; background: #ffffff; border-radius: 16px; }
    .loading-overlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.8); border-radius: 16px; }
  </style>
</head>
<body>
  <div class="container-fluid p-4">
    <div class="d-flex justify-content-between align-items-center top-bar">
      <div>
        <h2 class="mb-1"><i class="fas fa-cube me-2"></i>Network Topology 3D</h2>
        <p class="mb-0 text-muted">Interactive 3D Security Fabric View</p>
      </div>
      <div class="d-flex gap-2">
        <a class="btn btn-outline-secondary btn-sm" href="/topology"><i class="fas fa-layer-group me-1"></i>2D Topology View</a>
        <button id="autoRotateBtn" class="btn btn-outline-dark btn-sm" title="Toggle auto-rotate">
          <i class="fas fa-sync-alt me-1"></i>Auto-rotate
        </button>
        <button id="fitBtn" class="btn btn-outline-dark btn-sm" title="Fit to graph">
          <i class="fas fa-compress-arrows-alt me-1"></i>Fit
        </button>
        <div class="form-check form-switch d-inline-flex align-items-center ms-2" title="Performance mode">
          <input class="form-check-input" type="checkbox" id="perfModeSwitch">
          <label class="form-check-label ms-1" for="perfModeSwitch">Performance</label>
        </div>
        <button id="eraserExportBtn" class="btn btn-outline-primary btn-sm" disabled title="Enable ERASER_ENABLED to activate">
          <i class="fas fa-upload me-1"></i>Export to Eraser
        </button>
      </div>
    </div>
    <div id="notif" class="position-fixed top-0 end-0 p-3" style="z-index:1080;" aria-live="polite" role="status" aria-atomic="true"></div>
    <div class="topology-container">
      <div id="graph-3d" style="position: relative;"></div>
      <div id="loading" class="loading-overlay">
        <div class="text-center">
          <div class="spinner-border text-primary" role="status" aria-live="polite" aria-label="Loading topology"></div>
          <div class="mt-2 text-muted small">Loading topologyâ€¦</div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"
          integrity="sha384-5UGTcMIxVUKFeJH0zOS3lqMAZNBG+fCXJbi3UglUq6ABO4MQJu6rxNa+MPP+qtwq"
          crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>
  <script src="https://unpkg.com/3d-force-graph@1.73.4/dist/3d-force-graph.min.js"
          integrity="sha384-GNPicn8pBA2/PGSyPTpxIlPurgLUYcNYJ2zskIq782dE9+gp5E32WSyuxZqA7J+u"
          crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/js/all.min.js"
          integrity="sha384-xJg9IXkLBF6DBCGIEmpH5d2Pzct5onYpW8EegteK+7n0rxjhN4PUzfPxGbpWVjQf"
          crossorigin="anonymous" referrerpolicy="no-referrer" defer></script>

  <script>
    function showNotice(message, type = 'danger', timeoutMs = 5000) {
      let container = document.getElementById('notif');
      if (!container) {
        container = document.createElement('div');
        container.id = 'notif';
        container.className = 'position-fixed top-0 end-0 p-3';
        container.setAttribute('aria-live', 'polite');
        container.setAttribute('role', 'status');
        container.setAttribute('aria-atomic', 'true');
        document.body.appendChild(container);
      }
      const el = document.createElement('div');
      el.className = `alert alert-${type} shadow`;
      el.role = 'alert';
      el.innerText = message;
      container.appendChild(el);
      if (timeoutMs) setTimeout(() => el.remove(), timeoutMs);
    }

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(s);
      });
    }

    async function ensureDeps() {
      if (typeof THREE === 'undefined') {
        try {
          await loadScript('/static/vendor/three.min.js');
        } catch (e) {
          showNotice('Could not load Three.js (CDN and local fallback failed).', 'danger', 8000);
          throw e;
        }
      }
      if (typeof ForceGraph3D === 'undefined') {
        try {
          await loadScript('/static/vendor/3d-force-graph.min.js');
        } catch (e) {
          showNotice('Could not load 3D Force Graph (CDN and local fallback failed).', 'danger', 8000);
          throw e;
        }
      }
    }
  </script>

  <script>
    const TYPE_COLORS = {
      fortigate: '#2563eb',
      fortiswitch: '#059669',
      endpoint: '#7c3aed',
      server: '#dc2626'
    };
    const RISK_SIZE = { low: 6, medium: 8, high: 10, critical: 12 };

    async function loadData() {
      let res;
      try {
        const abs = new URL('/api/topology_data', window.location.origin).toString();
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), 8000);
        res = await fetch(abs, { cache: 'no-store', signal: controller.signal });
        clearTimeout(t);
      } catch (e) {
        showNotice('Network error loading topology data. Using fallback.', 'warning');
        return {
          devices: [
            { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Active' } },
            { id: 'switch_0', type: 'fortiswitch', name: 'FortiSwitch-1', ip: '192.168.0.10', risk: 'medium', details: { status: 'Authorized' } },
            { id: 'device_0', type: 'endpoint', name: 'Workstation', ip: '192.168.0.101', risk: 'low', details: { manufacturer: 'Generic' } }
          ],
          connections: [
            { from: 'fortigate_main', to: 'switch_0' },
            { from: 'switch_0', to: 'device_0' }
          ]
        };
      }
      if (!res.ok) {
        showNotice(`Failed to load topology data (${res.status})`, 'danger');
        // Fallback to minimal sample data
        return {
          devices: [
            { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Active' } },
            { id: 'switch_0', type: 'fortiswitch', name: 'FortiSwitch-1', ip: '192.168.0.10', risk: 'medium', details: { status: 'Authorized' } },
            { id: 'device_0', type: 'endpoint', name: 'Workstation', ip: '192.168.0.101', risk: 'low', details: { manufacturer: 'Generic' } }
          ],
          connections: [
            { from: 'fortigate_main', to: 'switch_0' },
            { from: 'switch_0', to: 'device_0' }
          ]
        };
      }
      try {
        return await res.json();
      } catch (e) {
        // If JSON parsing fails, use fallback
        return {
          devices: [
            { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Active' } }
          ],
          connections: []
        };
      }
    }

    function toGraphData(topology) {
      const nodes = (topology.devices || []).map(d => ({
        id: d.id,
        name: d.name,
        type: d.type,
        risk: d.risk || 'low',
        ip: d.ip || 'N/A',
        mac: d.mac || '',
        details: d.details || {}
      }));
      const links = (topology.connections || []).map(c => ({ source: c.from, target: c.to }));
      return { nodes, links };
    }

    let performanceMode = false;

    function makeLabelSprite(text, fontSizePx) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const pad = 30;
      ctx.font = `bold ${fontSizePx}px Segoe UI, Arial, sans-serif`;
      const textWidth = ctx.measureText(text).width;
      canvas.width = textWidth + pad;
      canvas.height = fontSizePx + pad;
      ctx.font = `bold ${fontSizePx}px Segoe UI, Arial, sans-serif`;
      ctx.fillStyle = '#111827';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, pad / 2, canvas.height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      material.depthWrite = false;
      const sprite = new THREE.Sprite(material);
      const scaleDivisor = performanceMode ? 5 : 4;
      sprite.scale.set(canvas.width / scaleDivisor, canvas.height / scaleDivisor, 1);
      sprite.position.set(0, -12, 0);
      return sprite;
    }

    function makeNodeObject(node) {
      const group = new THREE.Group();
      const size = RISK_SIZE[node.risk] || 6;
      const color = new THREE.Color(TYPE_COLORS[node.type] || '#6b7280');
      const segments = performanceMode ? 10 : 16;
      const geom = new THREE.SphereGeometry(size * 0.5, segments, segments);
      const mat = new THREE.MeshLambertMaterial({ color });
      const sphere = new THREE.Mesh(geom, mat);
      group.add(sphere);

      if (!performanceMode && node.risk && node.risk !== 'low') {
        const haloGeom = new THREE.SphereGeometry(size * 0.7, 16, 16);
        const riskColor = node.risk === 'critical' ? 0xdc2626 : node.risk === 'high' ? 0xef4444 : 0xf59e0b;
        const haloMat = new THREE.MeshBasicMaterial({ color: riskColor, transparent: true, opacity: 0.25 });
        const halo = new THREE.Mesh(haloGeom, haloMat);
        group.add(halo);
      }

      const labelFont = performanceMode ? 36 : 48;
      const label = makeLabelSprite(node.name || node.id, labelFont);
      group.add(label);

      return group;
    }

    function nodeLabel(node) {
      const status = node.details && node.details.status ? node.details.status : 'online';
      const man = node.details && node.details.manufacturer ? node.details.manufacturer : '';
      const host = node.details && node.details.hostname ? node.details.hostname : '';
      return `
        <div style="font-size:12px">
          <div><strong>${node.name}</strong></div>
          <div>IP: ${node.ip}</div>
          <div>Status: ${status}</div>
          <div>Risk: ${node.risk}</div>
          ${node.mac ? `<div>MAC: ${node.mac}</div>` : ''}
          ${man ? `<div>Manufacturer: ${man}</div>` : ''}
          ${host ? `<div>Hostname: ${host}</div>` : ''}
        </div>
      `;
    }

    window.addEventListener('DOMContentLoaded', async () => {
      const hideLoading = () => { const l = document.getElementById('loading'); if (l) l.style.display = 'none'; };
      try {
        await ensureDeps();
      } catch (e) {
        hideLoading();
        showNotice('3D libraries failed to load. Check network or local vendor files.', 'danger', 8000);
        console.error(e);
        return;
      }
      let raw;
      try {
        raw = await loadData();
      } catch (e) {
        console.warn('Falling back to sample topology after load error:', e);
        showNotice('Using sample topology (API error).', 'warning', 5000);
        raw = { devices: [ { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Degraded' } } ], connections: [] };
      }
      const data = toGraphData(raw);

      const containerEl = document.getElementById('graph-3d');
      const Graph = ForceGraph3D()(containerEl)
        .graphData(data)
        .nodeThreeObject(makeNodeObject)
        .nodeLabel(nodeLabel)
        .nodeColor(n => TYPE_COLORS[n.type] || '#6b7280')
        .nodeRelSize(4)
        .linkOpacity(0.55)
        .linkWidth(1.25)
        .backgroundColor('#ffffff')
        .showNavInfo(false);

      // Ensure correct initial sizing and handle window resize
      function resizeGraph() {
        const width = containerEl.clientWidth || containerEl.offsetWidth || 800;
        const height = containerEl.clientHeight || containerEl.offsetHeight || Math.round(window.innerHeight * 0.8);
        Graph.width(width);
        Graph.height(height);
      }
      resizeGraph();
      window.addEventListener('resize', resizeGraph);

      const scene = Graph.scene();
      const ambient = new THREE.AmbientLight(0xffffff, 0.9);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(1, 1, 1);
      scene.add(ambient);
      scene.add(dir);

      const controls = Graph.controls();
      controls.enableZoom = true;
      controls.autoRotate = false;
      controls.autoRotateSpeed = 1.0;

      // Lower device pixel ratio in performance mode
      const renderer = Graph.renderer();
      if (renderer && renderer.setPixelRatio) {
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      }

      Graph.onNodeClick(n => {
        console.log('Selected:', n);
      });

      // Initial simulation tuning for faster first paint
      try {
        if (typeof Graph.cooldownTicks === 'function') Graph.cooldownTicks(100);
        if (typeof Graph.enableNodeDrag === 'function') Graph.enableNodeDrag(true);
        const charge = Graph.d3Force && Graph.d3Force('charge');
        if (charge && typeof charge.strength === 'function') charge.strength(-90);
      } catch {}

      const eraserStatusUrl = new URL('/api/eraser/status', window.location.origin).toString();
      fetch(eraserStatusUrl)
        .then(r => r.ok ? r.json() : { enabled: false })
        .then(js => {
          if (js && js.enabled) {
            document.getElementById('eraserExportBtn').disabled = false;
          }
        })
        .catch(() => {});

      document.getElementById('eraserExportBtn').addEventListener('click', async () => {
        try {
          const exportUrl = new URL('/api/eraser/export', window.location.origin).toString();
          const res = await fetch(exportUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ topology: raw })
          });
          if (!res.ok) {
            showNotice(`Export failed (${res.status})`, 'danger');
            return;
          }
          const js = await res.json();
          showNotice(js.message || 'Exported', 'success', 3000);
        } catch (e) {
          showNotice('Eraser export not available', 'warning');
        }
      });

      // Hide loading overlay once initial frame is likely rendered
      setTimeout(hideLoading, 300);

      // Auto-rotate toggle
      const autoRotateBtn = document.getElementById('autoRotateBtn');
      let autoRotating = false;
      function setAutoRotate(on) {
        autoRotating = on;
        controls.autoRotate = on;
        if (controls.update) controls.update();
        autoRotateBtn.classList.toggle('btn-primary', on);
        autoRotateBtn.classList.toggle('btn-outline-dark', !on);
      }
      autoRotateBtn.addEventListener('click', () => setAutoRotate(!autoRotating));

      // Fit-to-graph
      const fitBtn = document.getElementById('fitBtn');
      function fitToGraph() {
        // Prefer built-in zoomToFit if available
        try {
          if (typeof Graph.zoomToFit === 'function') {
            Graph.zoomToFit(1000, 100);
            return;
          }
        } catch (e) {}
        const nodes = (Graph.graphData() && Graph.graphData().nodes) || [];
        if (!nodes.length) return;
        const withPos = nodes.filter(n => Number.isFinite(n.x) && Number.isFinite(n.y) && Number.isFinite(n.z));
        const pts = withPos.length ? withPos : nodes.map(n => ({ x: 0, y: 0, z: 0 }));
        let minX = Infinity, minY = Infinity, minZ = Infinity, maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        let cx = 0, cy = 0, cz = 0;
        pts.forEach(p => {
          minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
          minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
          cx += p.x; cy += p.y; cz += p.z;
        });
        cx /= pts.length; cy /= pts.length; cz /= pts.length;
        const dx = maxX - minX, dy = maxY - minY, dz = maxZ - minZ;
        const radius = Math.max(dx, dy, dz) / 2 || 100;
        const camera = Graph.camera();
        const fov = (camera && camera.fov) ? camera.fov : 60;
        const fovRad = fov * Math.PI / 180;
        const distance = (radius / Math.tan(fovRad / 2)) * 1.2;
        Graph.cameraPosition({ x: cx, y: cy, z: cz + distance }, { x: cx, y: cy, z: cz }, 1000);
      }
      fitBtn.addEventListener('click', fitToGraph);

      // Fit once after simulation settles
      let fittedOnce = false;
      if (typeof Graph.onEngineStop === 'function') {
        Graph.onEngineStop(() => {
          if (!fittedOnce) {
            fitToGraph();
            fittedOnce = true;
          }
        });
      }

      // Performance mode toggle
      const perfSwitch = document.getElementById('perfModeSwitch');
      function applyPerformanceMode(on) {
        performanceMode = on;
        // Renderer DPR
        if (renderer && renderer.setPixelRatio) {
          renderer.setPixelRatio(on ? 1 : Math.min(2, window.devicePixelRatio));
        }
        // Simulation tuning
        const charge = Graph.d3Force && Graph.d3Force('charge');
        if (charge && typeof charge.strength === 'function') {
          charge.strength(on ? -40 : -120);
        }
        if (typeof Graph.cooldownTicks === 'function') {
          Graph.cooldownTicks(on ? 80 : 200);
        }
        if (typeof Graph.enableNodeDrag === 'function') {
          Graph.enableNodeDrag(!on);
        }
        Graph.linkOpacity(on ? 0.45 : 0.55);
        Graph.linkWidth(on ? 1 : 1.25);
        // Rebuild node objects to apply perf-mode label/halo changes
        Graph.nodeThreeObject(makeNodeObject);
        Graph.graphData(Graph.graphData());
      }
      perfSwitch.addEventListener('change', (e) => applyPerformanceMode(e.target.checked));
    });
  </script>
</body>
</html>
