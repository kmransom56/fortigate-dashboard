<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FortiGate Network Topology 3D</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); }
    .top-bar { margin-bottom: 1rem; }
    .topology-container { background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); padding: 1rem; position: relative; }
    #graph-3d { width: 100%; height: 80vh; background: #ffffff; border-radius: 16px; }
    .loading-overlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.8); border-radius: 16px; }
  </style>
</head>
<body>
  <div class="container-fluid p-4">
    <div class="d-flex justify-content-between align-items-center top-bar">
      <div>
        <h2 class="mb-1"><i class="fas fa-cube me-2"></i>Network Topology 3D</h2>
        <p class="mb-0 text-muted">Interactive 3D Security Fabric View</p>
      </div>
      <div class="d-flex gap-2">
        <a class="btn btn-outline-secondary btn-sm" href="/topology"><i class="fas fa-layer-group me-1"></i>2D Topology View</a>
        <button id="autoRotateBtn" class="btn btn-outline-dark btn-sm" title="Toggle auto-rotate">
          <i class="fas fa-sync-alt me-1"></i>Auto-rotate
        </button>
        <button id="fitBtn" class="btn btn-outline-dark btn-sm" title="Fit to graph">
          <i class="fas fa-compress-arrows-alt me-1"></i>Fit
        </button>
        <div class="form-check form-switch d-inline-flex align-items-center ms-2" title="Performance mode">
          <input class="form-check-input" type="checkbox" id="perfModeSwitch">
          <label class="form-check-label ms-1" for="perfModeSwitch">Performance</label>
        </div>
        <button id="eraserExportBtn" class="btn btn-outline-primary btn-sm" disabled title="Enable ERASER_ENABLED to activate">
          <i class="fas fa-upload me-1"></i>Export to Eraser
        </button>
      </div>
    </div>
    <div id="notif" class="position-fixed top-0 end-0 p-3" style="z-index:1080;" aria-live="polite" role="status" aria-atomic="true"></div>
    <div class="topology-container">
      <div id="graph-3d" style="position: relative;"></div>
      <div id="loading" class="loading-overlay">
        <div class="text-center">
          <div class="spinner-border text-primary" role="status" aria-live="polite" aria-label="Loading topology"></div>
          <div class="mt-2 text-muted small">Loading topologyâ€¦</div>
        </div>
      </div>
    </div>
  </div>

  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
        rel="stylesheet"
        crossorigin="anonymous"
        referrerpolicy="no-referrer">
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';
    window.THREE = THREE;
  </script>
  <script src="/static/vendor/3d-force-graph.min.js" defer></script>

  <script>
    // Global error handlers to avoid stuck loading overlay
    function hideLoadingOverlay() {
      const l = document.getElementById('loading');
      if (l) l.style.display = 'none';
    }
    window.addEventListener('error', (e) => {
      hideLoadingOverlay();
      try { showNotice(`Runtime error: ${e.message}`, 'danger', 10000); } catch {}
    });
    window.addEventListener('unhandledrejection', (e) => {
      hideLoadingOverlay();
      const msg = (e && e.reason && e.reason.message) ? e.reason.message : 'Unhandled promise rejection';
      try { showNotice(`Runtime error: ${msg}`, 'danger', 10000); } catch {}
    });

    function showNotice(message, type = 'danger', timeoutMs = 5000) {
      const now = Date.now();
      const windowMs = 2000;
      if (!window.__notifState) {
        window.__notifState = { lastMsg: '', lastType: '', lastTs: 0, windowStart: now, count: 0 };
      }
      const st = window.__notifState;

      if (now - st.windowStart > windowMs) {
        st.windowStart = now;
        st.count = 0;
      }
      st.count += 1;
      if (st.count > 5) {
        return;
      }

      if (message === st.lastMsg && type === st.lastType && (now - st.lastTs) < windowMs) {
        return;
      }
      st.lastMsg = message;
      st.lastType = type;
      st.lastTs = now;

      let container = document.getElementById('notif');
      if (!container) {
        container = document.createElement('div');
        container.id = 'notif';
        container.className = 'position-fixed top-0 end-0 p-3';
        container.setAttribute('aria-live', 'polite');
        container.setAttribute('role', 'status');
        container.setAttribute('aria-atomic', 'true');
        document.body.appendChild(container);
      }
      const el = document.createElement('div');
      el.className = `alert alert-${type} shadow`;
      el.role = 'alert';
      el.innerText = message;
      container.appendChild(el);
      if (timeoutMs) setTimeout(() => el.remove(), timeoutMs);
    }

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(s);
      });
    }

    async function ensureDeps() {
      // Three.js is now loaded as ES module above
      if (typeof ForceGraph3D === 'undefined') {
        try {
          await loadScript('/static/vendor/3d-force-graph.min.js');
        } catch (e) {
          showNotice('Could not load 3D Force Graph (CDN and local fallback failed).', 'danger', 8000);
          throw e;
        }
      }
    }
  </script>

  <script>
    const TYPE_COLORS = {
      fortigate: '#2563eb',
      fortiswitch: '#059669',
      endpoint: '#7c3aed',
      server: '#dc2626',
      fortiap: '#10b981'
    };
    const RISK_SIZE = { low: 6, medium: 8, high: 10, critical: 12 };

    const ICON_MAP = {
      fortigate: '/static/icons/fortinet/png/fortigate.png',
      fortiswitch: '/static/icons/fortinet/png/fortiswitch.png',
      fortiap: '/static/icons/fortinet/png/fortiap.png',
      server: '/static/icons/fortinet/png/server_cloud.png',
      endpoint: '/static/icons/fortinet/png/endpoint_laptop.png'
    };

    async function loadData() {
      let res;
      try {
        const abs = new URL('/api/topology_data', window.location.origin).toString();
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), 8000);
        res = await fetch(abs, { cache: 'no-store', signal: controller.signal });
        clearTimeout(t);
      } catch (e) {
        showNotice('Network error loading topology data. Using fallback.', 'warning');
        return {
          devices: [
            { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Active' } },
            { id: 'switch_0', type: 'fortiswitch', name: 'FortiSwitch-1', ip: '192.168.0.10', risk: 'medium', details: { status: 'Authorized' } },
            { id: 'device_0', type: 'endpoint', name: 'Workstation', ip: '192.168.0.101', risk: 'low', details: { manufacturer: 'Generic' } }
          ],
          connections: [
            { from: 'fortigate_main', to: 'switch_0' },
            { from: 'switch_0', to: 'device_0' }
          ]
        };
      }
      if (!res.ok) {
        showNotice(`Failed to load topology data (${res.status})`, 'danger');
        // Fallback to minimal sample data
        return {
          devices: [
            { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Active' } },
            { id: 'switch_0', type: 'fortiswitch', name: 'FortiSwitch-1', ip: '192.168.0.10', risk: 'medium', details: { status: 'Authorized' } },
            { id: 'device_0', type: 'endpoint', name: 'Workstation', ip: '192.168.0.101', risk: 'low', details: { manufacturer: 'Generic' } }
          ],
          connections: [
            { from: 'fortigate_main', to: 'switch_0' },
            { from: 'switch_0', to: 'device_0' }
          ]
        };
      }
      try {
        return await res.json();
      } catch (e) {
        // If JSON parsing fails, use fallback
        return {
          devices: [
            { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Active' } }
          ],
          connections: []
        };
      }
    }

    function toGraphData(topology) {
      const nodes = (topology.devices || []).map(d => ({
        id: d.id,
        name: d.name,
        type: d.type,
        risk: d.risk || 'low',
        ip: d.ip || 'N/A',
        mac: d.mac || '',
        details: d.details || {}
      }));
      const links = (topology.connections || []).map(c => ({ source: c.from, target: c.to }));
      return { nodes, links };
    }

    let performanceMode = false;

    function makeCanvasIcon(nodeType, size) {
      const c = document.createElement('canvas');
      const s = Math.max(64, Math.floor(size * 12));
      c.width = s; c.height = s;
      const ctx = c.getContext('2d');
      ctx.clearRect(0,0,s,s);
      const base = TYPE_COLORS[nodeType] || '#6b7280';
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(s/2, s/2, s*0.48, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = Math.max(2, s*0.04);
      ctx.strokeStyle = base;
      ctx.stroke();
      ctx.fillStyle = base;
      if (nodeType === 'fortigate') {
        ctx.fillRect(s*0.25, s*0.35, s*0.5, s*0.3);
      } else if (nodeType === 'fortiswitch') {
        ctx.fillRect(s*0.2, s*0.3, s*0.6, s*0.16);
        ctx.fillRect(s*0.2, s*0.54, s*0.6, s*0.16);
      } else if (nodeType === 'fortiap') {
        ctx.beginPath();
        ctx.moveTo(s*0.5, s*0.2); ctx.lineTo(s*0.75, s*0.6); ctx.lineTo(s*0.25, s*0.6); ctx.closePath(); ctx.fill();
      } else if (nodeType === 'server') {
        ctx.fillRect(s*0.32, s*0.22, s*0.36, s*0.56);
      } else {
        ctx.beginPath();
        ctx.arc(s/2, s/2, s*0.22, 0, Math.PI*2); ctx.fill();
      }
      return new THREE.CanvasTexture(c);
    }
    function makeLabelSprite(text, fontSizePx) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const pad = 36;
      ctx.font = `bold ${fontSizePx}px Segoe UI, Arial, sans-serif`;
      const textWidth = ctx.measureText(text).width;
      canvas.width = Math.ceil(textWidth + pad);
      canvas.height = Math.ceil(fontSizePx + pad);
      ctx.font = `bold ${fontSizePx}px Segoe UI, Arial, sans-serif`;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.fillStyle = '#111827';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, pad / 2, canvas.height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      material.depthWrite = false;
      const sprite = new THREE.Sprite(material);
      const scaleDivisor = performanceMode ? 5.5 : 4.5;
      sprite.scale.set(canvas.width / scaleDivisor, canvas.height / scaleDivisor, 1);
      sprite.position.set(0, -12, 0);
      return sprite;
    }

    function makeNodeObject(node) {
      const group = new THREE.Group();
      const size = RISK_SIZE[node.risk] || 6;
      const color = new THREE.Color(TYPE_COLORS[node.type] || '#6b7280');
      const segments = performanceMode ? 10 : 16;
      const geom = new THREE.SphereGeometry(size * 0.5, segments, segments);
      const mat = new THREE.MeshLambertMaterial({ color });
      const sphere = new THREE.Mesh(geom, mat);
      group.add(sphere);

      // try icon sprite on top
      const iconUrl = (node.details && node.details.iconPath) || ICON_MAP[node.type] || null;
      if (iconUrl && !performanceMode) {
        try {
          const loader = new THREE.TextureLoader();
          loader.load(iconUrl, (texture) => {
            const planeMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(planeMat);
            const iconScale = 10;
            sprite.scale.set(iconScale, iconScale, 1);
            sprite.position.set(0, size * 0.9, 0);
            group.add(sprite);
          }, undefined, () => {
            const tex = makeCanvasIcon(node.type, size);
            const mat2 = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const spr2 = new THREE.Sprite(mat2);
            spr2.scale.set(10, 10, 1);
            spr2.position.set(0, size * 0.9, 0);
            group.add(spr2);
          });
        } catch (e) {
          // ignore texture load failures, we will still show label
        }
      }

      if (node.risk && node.risk !== 'low') {
        const haloGeom = new THREE.SphereGeometry(size * 0.7, 16, 16);
        const riskColor = node.risk === 'critical' ? 0xdc2626 : node.risk === 'high' ? 0xef4444 : 0xf59e0b;
        const haloMat = new THREE.MeshBasicMaterial({ color: riskColor, transparent: true, opacity: 0.25 });
        const halo = new THREE.Mesh(haloGeom, haloMat);
        group.add(halo);
      }

      const labelFont = performanceMode ? 36 : 48;
      const label = makeLabelSprite(node.name || node.id, labelFont);
      group.add(label);

      return group;
    }

    function nodeLabel(node) {
      const status = node.details && node.details.status ? node.details.status : 'online';
      const man = node.details && node.details.manufacturer ? node.details.manufacturer : '';
      const host = node.details && node.details.hostname ? node.details.hostname : '';
      return `
        <div style="font-size:12px; color:#111; background:#fff; border:1px solid #e5e7eb; border-radius:6px; padding:6px 8px; box-shadow:0 2px 8px rgba(0,0,0,0.08);">
          <div style="font-weight:600; color:#111;">${node.name}</div>
          <div><span style="color:#374151;">IP:</span> ${node.ip}</div>
          <div><span style="color:#374151;">Status:</span> ${status}</div>
          <div><span style="color:#374151;">Risk:</span> ${node.risk}</div>
          ${node.mac ? `<div><span style="color:#374151;">MAC:</span> ${node.mac}</div>` : ''}
          ${man ? `<div><span style="color:#374151;">Manufacturer:</span> ${man}</div>` : ''}
          ${host ? `<div><span style="color:#374151;">Hostname:</span> ${host}</div>` : ''}
        </div>
      `;
    }

    window.addEventListener('DOMContentLoaded', async () => {
      const hideLoading = hideLoadingOverlay;
      // Safety timer to ensure overlay never hangs forever
      setTimeout(() => {
        const stillVisible = document.getElementById('loading') && document.getElementById('loading').style.display !== 'none';
        if (stillVisible) {
          hideLoading();
          showNotice('Took too long to load. Showing what we have.', 'warning', 6000);
        }
      }, 12000);
      try {
        await ensureDeps();
      } catch (e) {
        hideLoading();
        showNotice('3D libraries failed to load. Check network or local vendor files.', 'danger', 8000);
        console.error(e);
        return;
      }
      let raw;
      try {
        raw = await loadData();
      } catch (e) {
        console.warn('Falling back to sample topology after load error:', e);
        showNotice('Using sample topology (API error).', 'warning', 5000);
        raw = { devices: [ { id: 'fortigate_main', type: 'fortigate', name: 'FortiGate-Main', ip: '192.168.0.254', risk: 'low', details: { status: 'Degraded' } } ], connections: [] };
      }
      const data = toGraphData(raw);

      const containerEl = document.getElementById('graph-3d');
      const Graph = ForceGraph3D()(containerEl)
        .graphData(data)
        .nodeThreeObject(makeNodeObject)
        .nodeLabel(nodeLabel)
        .nodeColor(n => TYPE_COLORS[n.type] || '#6b7280')
        .nodeRelSize(4)
        .linkColor(() => '#4b5563')
        .linkOpacity(0.6)
        .linkWidth(1.5)
        .backgroundColor('#ffffff')
        .showNavInfo(false);
      if (!data.links || data.links.length === 0) {
        showNotice('No connections found; showing devices only', 'warning', 3000);
      }

      // Ensure correct initial sizing and handle window resize
      function resizeGraph() {
        const width = containerEl.clientWidth || containerEl.offsetWidth || 800;
        const height = containerEl.clientHeight || containerEl.offsetHeight || Math.round(window.innerHeight * 0.8);
        Graph.width(width);
        Graph.height(height);
      }
      resizeGraph();
      window.addEventListener('resize', resizeGraph);

      const scene = Graph.scene();
      const ambient = new THREE.AmbientLight(0xffffff, 0.9);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(1, 1, 1);
      scene.add(ambient);
      scene.add(dir);

      const controls = Graph.controls();
      controls.enableZoom = true;
      controls.autoRotate = false;
      controls.autoRotateSpeed = 1.0;

      // Lower device pixel ratio in performance mode
      const renderer = Graph.renderer();
      if (renderer && renderer.setPixelRatio) {
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      }

      Graph.onNodeClick(async n => {
        try {
          const statusRes = await fetch(new URL('/api/eraser/status', window.location.origin));
          const status = statusRes.ok ? await statusRes.json() : { enabled: false };
          if (status && status.enabled && n && n.details && n.details.iconPath) {
            const abs = n.details.iconPath.startsWith('/') ? n.details.iconPath : `/static/${n.details.iconPath}`;
            const res = await fetch(new URL('/api/eraser/export', window.location.origin), {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ imageUrl: abs })
            });
            if (res.ok) {
              const js = await res.json();
              // If Eraser returns a textureUrl/modelUrl, we can attach it live
              if (js && (js.textureUrl || js.modelUrl)) {
                // Simple path: replace node icon sprite texture if provided
                if (js.textureUrl) {
                  n.details.textureUrl = js.textureUrl;
                  // Rebuild the node object to apply the new texture
                  Graph.nodeThreeObject(makeNodeObject);
                  Graph.graphData(Graph.graphData());
                  showNotice('Applied Eraser texture to node', 'success', 2500);
                } else {
                  showNotice('Eraser returned a 3D model (not auto-applied)', 'info', 3500);
                }
              } else {
                showNotice('Sent to Eraser for 3D generation', 'success', 2500);
              }
            }
          }
        } catch {}
        console.log('Selected:', n);
      });

      // Initial simulation tuning for faster first paint
      try {
        if (typeof Graph.cooldownTicks === 'function') Graph.cooldownTicks(140);
        if (typeof Graph.enableNodeDrag === 'function') Graph.enableNodeDrag(true);
        const charge = Graph.d3Force && Graph.d3Force('charge');
        if (charge && typeof charge.strength === 'function') charge.strength(-70);
        // Link distance tuned for hierarchical layers
        if (typeof Graph.d3Force === 'function') {
          const link = Graph.d3Force('link');
          if (link && typeof link.distance === 'function') link.distance(l => (l.source?.type === 'fortigate' ? 180 : 110));
        }
      } catch {}

      const eraserStatusUrl = new URL('/api/eraser/status', window.location.origin).toString();
      fetch(eraserStatusUrl)
        .then(r => r.ok ? r.json() : { enabled: false })
        .then(js => {
          if (js && js.enabled) {
            document.getElementById('eraserExportBtn').disabled = false;
          }
        })
        .catch(() => {});

      document.getElementById('eraserExportBtn').addEventListener('click', async () => {
        try {
          const exportUrl = new URL('/api/eraser/export', window.location.origin).toString();
          const res = await fetch(exportUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ topology: raw })
          });
          if (!res.ok) {
            showNotice(`Export failed (${res.status})`, 'danger');
            return;
          }
          const js = await res.json();
          showNotice(js.message || 'Exported', 'success', 3000);
        } catch (e) {
          showNotice('Eraser export not available', 'warning');
        }
      });

      // Hide loading overlay once initial frame is likely rendered
      setTimeout(hideLoading, 300);

      // Auto-rotate toggle
      const autoRotateBtn = document.getElementById('autoRotateBtn');
      let autoRotating = false;
      function setAutoRotate(on) {
        autoRotating = on;
        controls.autoRotate = on;
        if (controls.update) controls.update();
        autoRotateBtn.classList.toggle('btn-primary', on);
        autoRotateBtn.classList.toggle('btn-outline-dark', !on);
      }
      autoRotateBtn.addEventListener('click', () => setAutoRotate(!autoRotating));

      // Fit-to-graph
      const fitBtn = document.getElementById('fitBtn');
      function fitToGraph() {
        // Prefer built-in zoomToFit if available
        try {
          if (typeof Graph.zoomToFit === 'function') {
            Graph.zoomToFit(1000, 100);
            return;
          }
        } catch (e) {}
        const nodes = (Graph.graphData() && Graph.graphData().nodes) || [];
        if (!nodes.length) return;
        const withPos = nodes.filter(n => Number.isFinite(n.x) && Number.isFinite(n.y) && Number.isFinite(n.z));
        const pts = withPos.length ? withPos : nodes.map(n => ({ x: 0, y: 0, z: 0 }));
        let minX = Infinity, minY = Infinity, minZ = Infinity, maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        let cx = 0, cy = 0, cz = 0;
        pts.forEach(p => {
          minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
          minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
          cx += p.x; cy += p.y; cz += p.z;
        });
        cx /= pts.length; cy /= pts.length; cz /= pts.length;
        const dx = maxX - minX, dy = maxY - minY, dz = maxZ - minZ;
        const radius = Math.max(dx, dy, dz) / 2 || 100;
        const camera = Graph.camera();
        const fov = (camera && camera.fov) ? camera.fov : 60;
        const fovRad = fov * Math.PI / 180;
        const distance = (radius / Math.tan(fovRad / 2)) * 1.2;
        Graph.cameraPosition({ x: cx, y: cy, z: cz + distance }, { x: cx, y: cy, z: cz }, 1000);
      }
      fitBtn.addEventListener('click', fitToGraph);

      // Fit once after simulation settles
      let fittedOnce = false;
      if (typeof Graph.onEngineStop === 'function') {
        Graph.onEngineStop(() => {
          if (!fittedOnce) {
            fitToGraph();
            fittedOnce = true;
          }
        });
      }

      // Performance mode toggle
      const perfSwitch = document.getElementById('perfModeSwitch');
      function applyPerformanceMode(on) {
        performanceMode = on;
        // Renderer DPR
        if (renderer && renderer.setPixelRatio) {
          renderer.setPixelRatio(on ? 1 : Math.min(2, window.devicePixelRatio));
        }
        // Simulation tuning
        const charge = Graph.d3Force && Graph.d3Force('charge');
        if (charge && typeof charge.strength === 'function') {
          charge.strength(on ? -40 : -120);
        }
        if (typeof Graph.cooldownTicks === 'function') {
          Graph.cooldownTicks(on ? 80 : 200);
        }
        if (typeof Graph.enableNodeDrag === 'function') {
          Graph.enableNodeDrag(!on);
        }
        Graph.linkOpacity(on ? 0.45 : 0.55);
        Graph.linkWidth(on ? 1 : 1.25);
        // Rebuild node objects to apply perf-mode label/halo changes
        Graph.nodeThreeObject(makeNodeObject);
        Graph.graphData(Graph.graphData());
      }
      perfSwitch.addEventListener('change', (e) => applyPerformanceMode(e.target.checked));
    });
  </script>
</body>
</html>
