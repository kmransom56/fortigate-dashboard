<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>FortiGate Topology</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body { font-family: Lato, Helvetica, Arial, sans-serif; margin: 0; background: #f5f7fa; }
      .sidebar { width: 220px; background: #3a2a4d; color: #fff; position: fixed; top: 0; left: 0; bottom: 0; z-index: 100; }
      .sidebar .logo { padding: 20px; font-size: 1.2em; font-weight: bold; }
      .sidebar .menu { padding: 0 20px; }
      .sidebar .menu-item { padding: 12px 0; border-bottom: 1px solid #4b3b5a; cursor: pointer; transition: background 0.2s, color 0.2s; }
      .sidebar .menu-item:hover { background: #4b3b5a; }
      .sidebar .menu-item.active { background: #2e1f3a; color: #ffd700; }
      .sidebar .menu-item.active:hover { background: #3a2a4d; }
      .main-content { margin-left: 220px; padding: 0; }
      .header { background: #fff; padding: 16px 32px; border-bottom: 1px solid #eee; display: flex; align-items: center; justify-content: space-between; }
      .topology-area { position: relative; min-height: 800px; background: #fff; margin: 32px; border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.08); overflow: hidden; }
      #topologyMap { position: absolute; top: 0; left: 0; right: 0; bottom: 0; }
    </style>
</head>
<body>
  <div class="sidebar">
    <div class="logo">FORTINET</div>
    <div class="menu">
      <div class="menu-item" data-href="/">Dashboard</div>
      <div class="menu-item" data-href="/switches">Network</div>
      <div class="menu-item" data-placeholder="Policy & Objects">Policy & Objects</div>
      <div class="menu-item" data-placeholder="Security Profiles">Security Profiles</div>
      <div class="menu-item" data-placeholder="User & Authentication">User & Authentication</div>
      <div class="menu-item" data-placeholder="System">System</div>
      <div class="menu-item active" data-no-action="true">Security Fabric</div>
      <div class="menu-item active" data-href="/topology-fortigate">Physical Topology</div>
      <div class="menu-item" data-href="/topology">Logical Topology</div>
      <div class="menu-item" data-placeholder="Fabric Connectors">Fabric Connectors</div>
      <div class="menu-item" data-placeholder="Log & Report">Log & Report</div>
    </div>
  </div>
  <div class="main-content">
    <div class="header">
      <div>Security Fabric &gt; Physical Topology</div>
      <div>
        <button id="updateBtn" type="button" style="background:#4caf50;color:#fff;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;transition:background 0.2s;" onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4caf50'">Update Now</button>
      </div>
    </div>
    <div class="topology-area">
      <div id="topologyMap"></div>
    </div>
  </div>
  <script>
    // Global error handler
    window.addEventListener('error', function(e) {
      console.error('Global error:', e.error, e.message, e.filename, e.lineno);
    });
    
    window.addEventListener('unhandledrejection', function(e) {
      console.error('Unhandled promise rejection:', e.reason);
    });
    
    async function renderTopology() {
      const map = document.getElementById('topologyMap');
      const updateBtn = document.getElementById('updateBtn');
      
      // Show loading state
      if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
      }
      map.innerHTML = '<div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.2em;color:#666;">Loading topology...</div>';
      
      try {
        // Load icon manifest (optional)
        // This file may not exist in all deployments; if missing we fallback to
        // iconPath values returned by the API or to the default circle node.
        let iconManifest = null;
        try {
          const manifestResponse = await fetch('/static/icons/manifest.json');
          if (manifestResponse.ok) {
            iconManifest = await manifestResponse.json();
          } else {
            console.info('Icon manifest not available:', manifestResponse.status);
          }
        } catch (e) {
          console.info('Icon manifest not available (fetch failed):', e);
        }

        console.log('Fetching topology data from /api/scraped_topology...');
        const response = await fetch('/api/scraped_topology');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        console.log('Received topology data:', data);
        
        if (data && data.error) {
          throw new Error(data.error || 'Unknown error');
        }

        const metadata = data && data.metadata ? data.metadata : {};
        console.log('Metadata:', metadata);
        if (metadata && metadata.source === 'error') {
          throw new Error(metadata.error || 'Topology service returned an error');
        }

        const devices = Array.isArray(data.devices) ? data.devices : [];
        const connections = Array.isArray(data.connections) ? data.connections : [];
        console.log(`Found ${devices.length} devices and ${connections.length} connections`);

        if (devices.length === 0 && connections.length === 0) {
          console.warn('No topology data available');
          map.innerHTML = '<div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.2em;color:#666;text-align:center;">No topology data available.<br><span style="font-size:0.9em;">Verify FortiGate, FortiSwitch, and Redis connectivity.</span></div>';
          return;
        }

        console.log('Rendering topology with', devices.length, 'devices');
        map.innerHTML = '';

      // Create SVG for connections
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';

      // Map device ids to positions for connection rendering
      const devicePositions = {};
      devices.forEach(device => {
        devicePositions[device.id] = {
          x: device.position.x + 50, // center of node
          y: device.position.y + 50
        };
      });

      // Render connections as SVG lines
      connections.forEach(conn => {
        const from = devicePositions[conn.from];
        const to = devicePositions[conn.to];
        if (from && to) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', from.x);
          line.setAttribute('y1', from.y);
          line.setAttribute('x2', to.x);
          line.setAttribute('y2', to.y);
          line.setAttribute('stroke', '#888');
          line.setAttribute('stroke-width', '4');
          svg.appendChild(line);
        }
      });
      map.appendChild(svg);

      // Render device nodes
      devices.forEach((device, index) => {
          console.log(`Rendering device ${index + 1}:`, device);
          if (!device.position || typeof device.position.x === 'undefined' || typeof device.position.y === 'undefined') {
            console.error('Device missing position:', device);
            return;
          }
          const div = document.createElement('div');
          div.style.position = 'absolute';
          div.style.left = device.position.x + 'px';
          div.style.top = device.position.y + 'px';
          div.style.width = '100px';
          div.style.height = '100px';

          // Icon logic
          // Priority:
          //  1) API-provided iconPath (details.iconPath)
          //  2) Model-to-icon mapping via manifest.json (if present)
          //  3) Fallback circle
          let iconUrl = null;
          const model = device.model || (device.details && device.details.model) || '';
          const detailsIconPath = device.details && device.details.iconPath;

          if (detailsIconPath) {
            // iconPath is stored relative to app/static, e.g. "icons/FG-100F_101F.svg"
            iconUrl = '/static/' + detailsIconPath.replace(/^\//, '');
          } else if (model && iconManifest) {
            const upperModel = model.toUpperCase();
            if (iconManifest[upperModel]) {
              iconUrl = '/static/icons/' + iconManifest[upperModel];
            } else {
              const parts = upperModel.split(/[-_ ]/);
              for (const part of parts) {
                if (part.length > 3 && iconManifest[part]) {
                  iconUrl = '/static/icons/' + iconManifest[part];
                  break;
                }
              }
            }
          }

          if (iconUrl) {
            div.style.backgroundImage = `url('${iconUrl}')`;
            div.style.backgroundSize = 'contain';
            div.style.backgroundRepeat = 'no-repeat';
            div.style.backgroundPosition = 'center';
            div.style.cursor = 'pointer';
            div.innerHTML = '';

            const label = document.createElement('div');
            label.style.position = 'absolute';
            label.style.top = '105px';
            label.style.width = '120px';
            label.style.left = '-10px';
            label.style.textAlign = 'center';
            label.style.fontWeight = 'bold';
            label.style.fontSize = '12px';
            label.style.color = '#333';
            label.textContent = device.name;
            div.appendChild(label);
          } else {
            div.style.borderRadius = '50%';
            div.style.background = device.details && device.details.color ? device.details.color : '#2196f3';
            div.style.color = '#fff';
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.justifyContent = 'center';
            div.style.fontSize = '1.2em';
            div.style.boxShadow = '0 2px 12px rgba(0,0,0,0.12)';
            div.style.cursor = 'pointer';
            div.innerHTML = `<div><strong>${device.name}</strong><br>${device.details && device.details.deviceCount ? device.details.deviceCount + ' Devices' : ''}</div>`;
          }

          // Advanced tooltip (popover)
          const tooltip = document.createElement('div');
          tooltip.style.position = 'absolute';
          tooltip.style.left = '110px';
          tooltip.style.top = '0px';
          tooltip.style.minWidth = '180px';
          tooltip.style.background = '#fff';
          tooltip.style.color = '#333';
          tooltip.style.border = '1px solid #ccc';
          tooltip.style.borderRadius = '8px';
          tooltip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
          tooltip.style.padding = '12px';
          tooltip.style.zIndex = '1000';
          tooltip.style.display = 'none';
          tooltip.innerHTML = `
            <div style="font-weight:bold;font-size:1.1em;margin-bottom:4px;">${device.name}</div>
            <div>Type: <span style="color:${device.details && device.details.color ? device.details.color : '#2196f3'};font-weight:bold;">${device.type}</span></div>
            <div>Model: ${model || 'Unknown'}</div>
            <div>Count: ${device.details && device.details.deviceCount ? device.details.deviceCount : 1}</div>
            <div>Position: (${device.position.x}, ${device.position.y})</div>
            <div>Status: ${device.status ? device.status : 'unknown'}</div>
            <div>Risk: ${device.risk ? device.risk : 'unknown'}</div>
          `;
          div.appendChild(tooltip);

          div.addEventListener('mouseenter', () => {
            tooltip.style.display = 'block';
          });
          div.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
          });

          map.appendChild(div);
        });
      } catch (error) {
        console.error('Error loading topology:', error);
        map.innerHTML = `<div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.2em;color:#d32f2f;text-align:center;">
          <div style="margin-bottom:8px;">⚠️ Error loading topology</div>
          <div style="font-size:0.9em;color:#666;">${error.message}</div>
        </div>`;
      } finally {
        // Restore button state
        if (updateBtn) {
          updateBtn.disabled = false;
          updateBtn.textContent = 'Update Now';
        }
      }
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Page loaded, initializing topology...');
      
      // Add click handler for Update button
      const updateBtn = document.getElementById('updateBtn');
      if (updateBtn) {
        console.log('Update button found, attaching click handler');
        updateBtn.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          console.log('Update button clicked');
          renderTopology();
        });
      } else {
        console.error('Update button not found!');
      }
      
      // Add click handlers for all menu items
      document.querySelectorAll('.menu-item').forEach(function(item) {
        // Skip items that shouldn't be clickable
        if (item.dataset.noAction === 'true') {
          return;
        }
        
        item.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          const href = item.dataset.href;
          const placeholder = item.dataset.placeholder;
          
          console.log('Menu item clicked:', item.textContent.trim(), {href, placeholder});
          
          if (href) {
            console.log('Navigating to:', href);
            window.location.href = href;
          } else if (placeholder) {
            console.log('Placeholder feature clicked:', placeholder);
            alert('This feature is not yet implemented: ' + placeholder);
          } else {
            console.warn('Menu item has no action:', item.textContent.trim());
          }
        });
      });
      
      // Initial render
      renderTopology();
    });
  </script>
</body>
</html>
