<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FortiGate Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<div class="container mt-5">
    <h2>Network Map</h2>
    <div id="network" style="height: 400px; border: 1px solid lightgray;"></div>
    
    <h3>Connected Devices</h3>
    <table class="table table-striped table-bordered">
        <thead>
            <tr>
                <th>Device</th>
                <th>MAC Address</th>
                <th>IP Address</th>
                <th>Type</th>
                <th>Vendor</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="device-table-body">
            <!-- Device data will be populated by JavaScript -->
        </tbody>
    </table>
</div>

<body>
<div class="container mt-5">
    <h1>FortiGate Interface Dashboard</h1>
    <div class="container mt-2">
        <div class="row">
            <div class="col-md-4">
                <p id="refresh-timer">Refreshing in 10 seconds...</p>
            </div>
            <div class="col-md-4">
                <div class="form-group">
                    <label for="vendor-filter">Filter by Vendor:</label>
                    <select id="vendor-filter" class="form-control">
                        <option value="all">All Vendors</option>
                        <!-- Vendor options will be populated by JavaScript -->
                    </select>
                </div>
            </div>
            <div class="col-md-4 text-end">
                <a href="/" class="btn btn-secondary">Home</a>
                <a href="/switches" class="btn btn-success">View FortiSwitch Dashboard</a>
                <button id="refresh-vendor-cache" class="btn btn-info">Refresh Vendor Data</button>
            </div>
        </div>
    </div>
    
    <!-- Vendor Legend -->
    <div class="vendor-filter-legend mt-3" id="vendor-legend">
        <!-- Will be populated by JavaScript -->
    </div>
    <div id="wan-alert" class="alert alert-danger" role="alert" style="display:none;">
        ⚠️ WARNING: WAN Link Down Detected!
    </div>
    <table class="table table-striped table-bordered">
        <thead>
            <tr>
                <th>Interface</th>
                <th>IP Address</th>
                <th>Status</th>
                <th>Speed (Mbps)</th>
                <th>TX Bytes</th>
                <th>RX Bytes</th>
            </tr>
        </thead>
        <tbody>
            {% for name, iface in interfaces.items() %}
<tr {% if iface['name'] in ['wan1', 'wan2'] and not iface['link'] %} class="table-danger" {% endif %}>
    <td>{{ iface['name'] }}</td>
    <td>{{ iface['ip'] }}</td>
    <td>
        {% if iface['link'] %}
            <span class="badge bg-success">Up</span>
        {% else %}
            <span class="badge bg-danger">Down</span>
        {% endif %}
    </td>
    <td>{{ iface['speed'] }}</td>
    <td>{{ iface['tx_bytes'] | int }}</td>
    <td>{{ iface['rx_bytes'] | int }}</td>
</tr>
{% endfor %}
    </tbody>
    </table>
    <div class="container mt-5">
        <h2>Interface Traffic (TX Bytes)</h2>
        <canvas id="trafficChart"></canvas>
    </div>
    <div class="container mt-5">
        <h2>Interface Traffic (RX Bytes)</h2>
        <canvas id="rxTrafficChart"></canvas>
    </div>
</div>
</body>
<script>
    var seconds = 300;
    var countdownElement = document.getElementById('refresh-timer');

    async function fetchDashboardData() {
        return fetch('/api/dashboard')
            .then(response => response.json())
            .then(data => {
                // Check if the response has the expected format
                if (data.success) {
                    // Update the network visualization with interface and device data
                    if (data.interfaces) {
                        // If we have devices, pass them to updateNetwork
                        if (data.devices && Array.isArray(data.devices)) {
                            updateNetwork(data.interfaces, data.devices);
                        } else {
                            updateNetwork(data.interfaces, []);
                        }
                        updateCharts(data.interfaces);
                        checkWanAlerts(data.interfaces);
                    } else {
                        console.error('No interfaces data in the response');
                    }
                    
                    // If we have devices from the API response, use them
                    if (data.devices && Array.isArray(data.devices)) {
                        populateDeviceTable(data.devices);
                    } else {
                        // Fallback: Fetch connected devices from the switches API
                        fetch('/api/switches')
                            .then(response => response.json())
                            .then(switchData => {
                                if (switchData.success && switchData.switches) {
                                    let allDevices = [];
                                    
                                    // Process devices from each switch
                                    switchData.switches.forEach(switchInfo => {
                                        if (switchInfo.connected_devices && Array.isArray(switchInfo.connected_devices)) {
                                            allDevices = allDevices.concat(switchInfo.connected_devices);
                                        }
                                    });

                                    // Alias connected_devices as devices for compatibility
                                    const devices = allDevices;

                                    // If we have devices from the API response, use them
                                    if (devices.length > 0) {
                                        // Populate the device table
                                        populateDeviceTable(devices);
                                    }
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching switch data:', error);
                            });
                    }
                } else {
                    console.error('API response indicates failure:', data.error || 'Unknown error');
                }
                
                return data; // Return data for further processing
            })
            .catch(error => {
                console.error('Error fetching dashboard data:', error);
                return null;
            });
    }

    async function fetchNewData() {
        const response = await fetchDashboardData();
        if (response && response.interfaces) {
            updateTable(response.interfaces);
        }
    }

    function countdown() {
        if (seconds > 0) {
            countdownElement.innerHTML = 'Refreshing in ' + seconds + ' seconds...';
            seconds--;
        } else {
            fetchNewData();
            seconds = 10;  // reset timer
        }
    }
    setInterval(countdown, 1000);

    function updateTable(interfaces) {
        let tableBody = document.querySelector('tbody');
        tableBody.innerHTML = '';

        for (const [name, iface] of Object.entries(interfaces)) {
            let row = `<tr ${iface.name.startsWith('wan') && !iface.link ? 'class="table-danger"' : ''}>
                <td>${iface.name}</td>
                <td>${iface.ip}</td>
                <td>${iface.link ? '<span class="badge bg-success">Up</span>' : '<span class="badge bg-danger">Down</span>'}</td>
                <td>${iface.speed}</td>
                <td>${iface.tx_bytes}</td>
                <td>${iface.rx_bytes}</td>
            </tr>`;
            tableBody.innerHTML += row;
        }
    }

    // Traffic Chart (TX Bytes)
var ctxTx = document.getElementById('trafficChart').getContext('2d');
var trafficChart = new Chart(ctxTx, {
    type: 'bar',
    data: {
        labels: [],
        datasets: [{
            label: 'TX Bytes',
            data: [],
            backgroundColor: 'rgba(54, 162, 235, 0.7)'
        }]
    },
    options: {
        responsive: true,
        scales: {
            y: {
                beginAtZero: true
            }
        }
    }
});

// NEW: Traffic Chart (RX Bytes)
var ctxRx = document.getElementById('rxTrafficChart').getContext('2d');
var rxTrafficChart = new Chart(ctxRx, {
    type: 'bar',
    data: {
        labels: [],
        datasets: [{
            label: 'RX Bytes',
            data: [],
            backgroundColor: 'rgba(255, 99, 132, 0.7)'
        }]
    },
    options: {
        responsive: true,
        scales: {
            y: {
                beginAtZero: true
            }
        }
    }
});

// Update Charts function
function updateChart(interfaces) {
    trafficChart.data.labels = Object.values(interfaces).map(iface => iface.name);
    trafficChart.data.datasets[0].data = Object.values(interfaces).map(iface => iface.tx_bytes);
    trafficChart.update();

    rxTrafficChart.data.labels = Object.values(interfaces).map(iface => iface.name);
    rxTrafficChart.data.datasets[0].data = Object.values(interfaces).map(iface => iface.rx_bytes);
    rxTrafficChart.update();
}

    // vis-network Map
    var container = document.getElementById('network');
var network = null;

// Add CSS for vendor badges
const styleElement = document.createElement('style');
styleElement.textContent = `
    .vendor-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        color: white;
        font-size: 0.85rem;
        font-weight: bold;
    }
    .device-icon {
        width: 24px;
        height: 24px;
        margin-right: 5px;
        vertical-align: middle;
    }
    .vendor-filter-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 15px;
    }
    .vendor-filter-item {
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 5px 10px;
        border-radius: 5px;
        transition: background-color 0.2s;
    }
    .vendor-filter-item:hover {
        background-color: #f0f0f0;
    }
    .vendor-filter-item.active {
        background-color: #e0e0e0;
    }
    .toast-container {
        z-index: 9999;
    }
    .toast {
        min-width: 250px;
    }
`;
document.head.appendChild(styleElement);

// Function to get vendor from MAC prefix
function getVendorFromMacPrefix(macPrefix) {
    const vendorMap = {
        // Cisco
        '00:0C:29': 'Cisco',
        '00:40:96': 'Cisco',
        '00:60:09': 'Cisco',
        '00:80:C8': 'Cisco',
        '00:1A:A1': 'Cisco',
        '00:1A:A2': 'Cisco',
        '00:1A:E3': 'Cisco',
        
        // Dell
        '00:14:22': 'Dell',
        '00:1E:C9': 'Dell',
        'F8:BC:12': 'Dell',
        'F8:DB:88': 'Dell',
        
        // HP
        '00:0F:61': 'HP',
        '00:10:83': 'HP',
        '00:17:A4': 'HP',
        '94:57:A5': 'HP',
        '9C:8E:99': 'HP',
        
        // Apple
        '00:03:93': 'Apple',
        '00:05:02': 'Apple',
        '00:0A:27': 'Apple',
        '00:0A:95': 'Apple',
        '00:1E:52': 'Apple',
        '00:25:00': 'Apple',
        '00:26:BB': 'Apple',
        '00:30:65': 'Apple',
        '00:50:E4': 'Apple',
        '00:56:CD': 'Apple',
        
        // Fortinet
        '00:09:0F': 'Fortinet',
        '08:5B:0E': 'Fortinet',
        '00:90:6C': 'Fortinet',
        'E0:23:FF': 'Fortinet',
        
        // Common IoT devices
        'EC:FA:BC': 'IP Camera',
        '00:1A:79': 'Smart Device',
        
        // Samsung
        '00:15:99': 'Samsung',
        '00:17:D5': 'Samsung',
        '00:21:19': 'Samsung',
        '00:23:39': 'Samsung',
        '00:24:54': 'Samsung',
        
        // Printers
        '00:17:C8': 'Printer',
        '00:21:5A': 'Printer',
        '00:26:73': 'Printer',
        
        // IP Phones
        '00:04:F2': 'IP Phone',
        '00:07:0E': 'IP Phone',
        '00:0E:08': 'IP Phone',
        
        // Microsoft/Xbox
        'FC:8C:11': 'Xbox',
        '3C:18:A0': 'Microsoft',
        '0C:37:96': 'Microsoft',
        'D8:43:AE': 'Microsoft',
        
        // Other common vendors
        '38:14:28': 'Huawei',
        '10:7C:61': 'Lenovo',
        'DC:A6:32': 'Raspberry Pi',
        'C4:8B:A3': 'Meraki'
    };
    
    // Try to match the first 8 chars (includes colons)
    if (vendorMap[macPrefix]) {
        return vendorMap[macPrefix];
    }
    
    // Try to match just the first 3 bytes (XX:XX:XX format)
    const firstThreeBytes = macPrefix.substring(0, 8);
    if (vendorMap[firstThreeBytes]) {
        return vendorMap[firstThreeBytes];
    }
    
    return '';
}

// Base64 encoded SVG icons
const icons = {
    fortigate: '/static/icons/fortinet-icons/fortigate.svg',
    wan: '/static/icons/fortinet-icons/wan.svg',
    lan: '/static/icons/fortinet-icons/lan.svg',
    interface: '/static/icons/device.svg',
    device: '/static/icons/device.svg'
};

function updateNetwork(interfaces, devices = []) {
    var nodes = new vis.DataSet([
        { 
            id: 1, 
            label: 'FortiGate\n[Fortinet]', 
            shape: 'image', 
            image: icons.fortigate,
            size: 40,
            font: { size: 14, color: '#ff0000', face: 'Tahoma', strokeWidth: 2, strokeColor: '#ffffff' }
        }
    ]);

    var edges = [];
    let counter = 2;

    for (const [name, iface] of Object.entries(interfaces)) {
        if (!iface.ip || iface.ip === '0.0.0.0') {
            continue;
        }

        let interfaceIcon = icons.interface;
        let iconColor = '#0076CE';

        if (iface.name.toLowerCase().includes('wan')) {
            interfaceIcon = icons.wan;
        } else if (iface.name.toLowerCase().includes('lan') || iface.name.toLowerCase().includes('port')) {
            interfaceIcon = icons.lan;
        }

        nodes.add({
            id: counter,
            label: `${iface.name}\n${iface.ip}`,
            shape: 'image',
            image: interfaceIcon,
            size: 30,
            color: { border: iface.link ? '#00b300' : '#ff0000' },
            font: { size: 14, color: iconColor, face: 'Tahoma', strokeWidth: 2, strokeColor: '#ffffff' }
        });
        edges.push({
            from: 1,
            to: counter,
            width: 3,
            color: { color: iface.link ? '#00b300' : '#ff0000' },
            arrows: {
                to: { enabled: true, scaleFactor: 0.5 }
            }
        });
        counter++;
    }

    if (devices && devices.length > 0) {
        devices.forEach(device => {
            let deviceIcon = icons.device;
            let deviceColor = '#0076CE';

            nodes.add({
                id: counter,
                label: `${device.name}\n${device.ip}\n[${device.vendor}]`,
                shape: 'image',
                image: deviceIcon,
                size: 30,
                color: { border: device.status === 'online' ? '#00b300' : '#ff0000' },
                font: { size: 14, color: deviceColor, face: 'Tahoma', strokeWidth: 2, strokeColor: '#ffffff' }
            });

            edges.push({
                from: 1,
                to: counter,
                width: 2,
                color: { color: device.status === 'online' ? '#00b300' : '#ff0000' },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.5 }
                }
            });

            counter++;
        });
    }

    var data = {
        nodes: nodes,
        edges: edges
    };

    var options = {
        nodes: {
            borderWidth: 2,
            shadow: true
        },
        edges: {
            smooth: {
                type: 'continuous'
            }
        },
        layout: {
            improvedLayout: true,
            hierarchical: {
                enabled: false,
                direction: 'UD',
                sortMethod: 'directed'
            }
        },
        interaction: {
            navigationButtons: true,
            keyboard: true,
            hover: true
        }
    };

    if (network) {
        network.setData(data);
    } else {
        network = new vis.Network(container, data, options);
    }
}

// Function to check WAN status and show alerts
function checkWanAlerts(interfaces) {
    const wan1 = interfaces['wan1'];
    const wan2 = interfaces['wan2'];

    const alertBox = document.getElementById('wan-alert');

    if ((wan1 && !wan1.link) || (wan2 && !wan2.link)) {
        alertBox.style.display = 'block';  // Show alert
    } else {
        alertBox.style.display = 'none';   // Hide alert
    }
}

// Function to populate the device table
function populateDeviceTable(devices) {
    const tableBody = document.getElementById('device-table-body');
    if (!tableBody) return;
    
    // Clear existing rows
    tableBody.innerHTML = '';
    
    // Collect all unique vendors for the filter
    const vendors = new Set();
    const vendorColors = {};
    
    // Add device rows
    devices.forEach(device => {
        const row = document.createElement('tr');
        
        // Get vendor from MAC address if available
        let vendorName = 'Unknown';
        let vendorColor = '#505050';
        if (device.mac && device.mac !== 'Unknown') {
            // Extract first 8 characters of MAC (including colons)
            const macPrefix = device.mac.substring(0, 8).toUpperCase();
            vendorName = getVendorFromMacPrefix(macPrefix) || 'Unknown';
            
            // Assign color based on vendor
            if (vendorName === 'Cisco') vendorColor = '#049fd9';
            else if (vendorName === 'Dell') vendorColor = '#007db8';
            else if (vendorName === 'HP') vendorColor = '#0096d6';
            else if (vendorName === 'Apple') vendorColor = '#999999';
            else if (vendorName === 'Fortinet') vendorColor = '#ee3124';
            else if (vendorName === 'Samsung') vendorColor = '#1428a0';
            else if (vendorName === 'Microsoft' || vendorName === 'Xbox') vendorColor = '#7fba00';
            else if (vendorName.includes('Phone')) vendorColor = '#83b81a';
            else if (vendorName.includes('Printer')) vendorColor = '#000000';
            else if (vendorName.includes('Camera')) vendorColor = '#e3008c';
            else vendorColor = '#505050';
            
            // Add to vendors set for filter
            vendors.add(vendorName);
            vendorColors[vendorName] = vendorColor;
        }
        
        row.className = 'device-row';
        row.setAttribute('data-vendor', vendorName);
        
        row.innerHTML = `
            <td>${device.name || 'Unknown'}</td>
            <td>${device.mac || 'Unknown'}</td>
            <td>${device.ip || 'Unknown'}</td>
            <td>${device.type || 'Unknown'}</td>
            <td>
                <span class="vendor-badge" style="background-color: ${vendorColor}">
                    ${vendorName}
                </span>
            </td>
            <td>${device.status || 'Unknown'}</td>
            <td>
                <button class="btn btn-sm btn-info lookup-vendor" data-mac="${device.mac || ''}">Lookup</button>
            </td>
        `;
        
        tableBody.appendChild(row);
    });
    
    // Update vendor filter dropdown
    populateVendorFilter(vendors, vendorColors);
    
    // Update vendor legend
    updateVendorLegend(vendors, vendorColors);
}

// Function to populate vendor filter dropdown
function populateVendorFilter(vendors, vendorColors) {
    const vendorFilter = document.getElementById('vendor-filter');
    if (!vendorFilter) return;
    
    // Clear existing options except the first one
    while (vendorFilter.options.length > 1) {
        vendorFilter.remove(1);
    }
    
    // Add vendor options
    vendors.forEach(vendor => {
        const option = document.createElement('option');
        option.value = vendor;
        option.textContent = vendor;
        vendorFilter.appendChild(option);
    });
    
    // Add event listener
    vendorFilter.addEventListener('change', filterDevicesByVendor);
}

// Function to update vendor legend
function updateVendorLegend(vendors, vendorColors) {
    const legend = document.getElementById('vendor-legend');
    if (!legend) return;
    
    // Clear existing legend
    legend.innerHTML = '';
    
    // Add legend items
    vendors.forEach(vendor => {
        const item = document.createElement('div');
        item.className = 'vendor-filter-item';
        item.setAttribute('data-vendor', vendor);
        item.innerHTML = `
            <span class="vendor-badge" style="background-color: ${vendorColors[vendor] || '#505050'}">
                ${vendor}
            </span>
        `;
        
        // Add click event to filter
        item.addEventListener('click', () => {
            document.getElementById('vendor-filter').value = vendor;
            filterDevicesByVendor();
            
            // Update active state
            document.querySelectorAll('.vendor-filter-item').forEach(el => {
                el.classList.remove('active');
            });
            item.classList.add('active');
        });
        
        legend.appendChild(item);
    });
    
    // Add 'All' option to legend
    const allItem = document.createElement('div');
    allItem.className = 'vendor-filter-item active';
    allItem.setAttribute('data-vendor', 'all');
    allItem.innerHTML = `
        <span class="vendor-badge" style="background-color: #0078d7">
            All Vendors
        </span>
    `;
    
    // Add click event to show all
    allItem.addEventListener('click', () => {
        document.getElementById('vendor-filter').value = 'all';
        filterDevicesByVendor();
        
        // Update active state
        document.querySelectorAll('.vendor-filter-item').forEach(el => {
            el.classList.remove('active');
        });
        allItem.classList.add('active');
    });
    
    legend.insertBefore(allItem, legend.firstChild);
}

// Function to filter devices by vendor
function filterDevicesByVendor() {
    const selectedVendor = document.getElementById('vendor-filter').value;
    const deviceRows = document.querySelectorAll('.device-row');
    
    deviceRows.forEach(row => {
        const vendor = row.getAttribute('data-vendor');
        if (selectedVendor === 'all' || vendor === selectedVendor) {
            row.style.display = '';
        } else {
            row.style.display = 'none';
        }
    });
    
    // Update the network graph to show only the selected vendor
    updateNetworkWithVendorFilter(selectedVendor);
}

// Function to update the network graph with vendor filter
function updateNetworkWithVendorFilter(selectedVendor) {
    if (!network) return;
    
    const nodes = network.body.data.nodes;
    const nodeIds = nodes.getIds();
    
    nodeIds.forEach(id => {
        const node = nodes.get(id);
        if (id === 1) return; // Skip the FortiGate node
        
        const nodeLabel = node.label || '';
        const vendorMatch = nodeLabel.match(/\[(.*?)\]/); // Extract vendor from [Vendor] in label
        
        if (selectedVendor === 'all') {
            nodes.update({ id: id, hidden: false });
        } else if (vendorMatch && vendorMatch[1] === selectedVendor) {
            nodes.update({ id: id, hidden: false });
        } else if (vendorMatch) {
            nodes.update({ id: id, hidden: true });
        }
    });
}

// Function to look up vendor online
function lookupVendorOnline(mac) {
    // Show loading indicator
    const loadingToast = showToast('Looking up vendor information...', 'info');
    
    fetch(`/api/lookup-vendor?mac=${encodeURIComponent(mac)}`)
        .then(response => response.json())
        .then(data => {
            // Hide loading indicator
            hideToast(loadingToast);
            
            if (data.success) {
                showToast(`Vendor found: ${data.vendor}`, 'success');
                // Refresh the data to show the updated vendor
                fetchDashboardData();
            } else {
                showToast(`Vendor lookup failed: ${data.error}`, 'error');
            }
        })
        .catch(error => {
            hideToast(loadingToast);
            showToast(`Error: ${error.message}`, 'error');
        });
}

// Toast notification functions
function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.innerHTML = `
        <div class="toast-header">
            <strong class="me-auto">${type.charAt(0).toUpperCase() + type.slice(1)}</strong>
            <button type="button" class="btn-close" onclick="this.parentElement.parentElement.remove()"></button>
        </div>
        <div class="toast-body">${message}</div>
    `;
    
    // Add toast container if it doesn't exist
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
        document.body.appendChild(toastContainer);
    }
    
    toastContainer.appendChild(toast);
    return toast;
}

function hideToast(toast) {
    if (toast && toast.parentElement) {
        toast.remove();
    }
}

// Add event listeners for vendor lookup buttons
document.addEventListener('click', function(event) {
    if (event.target.classList.contains('lookup-vendor')) {
        const mac = event.target.getAttribute('data-mac');
        if (mac) {
            lookupVendorOnline(mac);
        }
    }
});

// Add event listener for refresh vendor cache button
document.getElementById('refresh-vendor-cache').addEventListener('click', function() {
    fetch('/api/refresh-vendor-cache')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showToast('Vendor cache refreshed successfully', 'success');
                fetchDashboardData();
            } else {
                showToast(`Failed to refresh vendor cache: ${data.error}`, 'error');
            }
        })
        .catch(error => {
            showToast(`Error: ${error.message}`, 'error');
        });
});

// Initial data fetch
fetchDashboardData();
</script>

</html>
